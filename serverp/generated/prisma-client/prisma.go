// Code generated by Prisma CLI (https://github.com/prisma/prisma). DO NOT EDIT.

package prisma

import (
	"context"
	"errors"

	"github.com/prisma/prisma-client-lib-go"

	"github.com/machinebox/graphql"
)

var ErrNoResult = errors.New("query returned no result")

func Str(v string) *string { return &v }
func Int32(v int32) *int32 { return &v }
func Bool(v bool) *bool    { return &v }

type BatchPayloadExec struct {
	exec *prisma.BatchPayloadExec
}

func (exec *BatchPayloadExec) Exec(ctx context.Context) (BatchPayload, error) {
	bp, err := exec.exec.Exec(ctx)
	return BatchPayload(bp), err
}

type BatchPayload struct {
	Count int64 `json:"count"`
}

type Aggregate struct {
	Count int64 `json:"count"`
}

type Client struct {
	Client *prisma.Client
}

type Options struct {
	Endpoint string
	Secret   string
}

func New(options *Options, opts ...graphql.ClientOption) *Client {
	endpoint := DefaultEndpoint
	secret := Secret
	if options != nil {
		endpoint = options.Endpoint
		secret = options.Secret
	}
	return &Client{
		Client: prisma.New(endpoint, secret, opts...),
	}
}

func (client *Client) GraphQL(ctx context.Context, query string, variables map[string]interface{}) (map[string]interface{}, error) {
	return client.Client.GraphQL(ctx, query, variables)
}

var DefaultEndpoint = "http://localhost:4466"
var Secret = ""

func (client *Client) Asset(params AssetWhereUniqueInput) *AssetExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"AssetWhereUniqueInput!", "Asset"},
		"asset",
		[]string{"id", "name", "uuid", "path", "note", "mimeType"})

	return &AssetExec{ret}
}

type AssetsParams struct {
	Where   *AssetWhereInput   `json:"where,omitempty"`
	OrderBy *AssetOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32             `json:"skip,omitempty"`
	After   *string            `json:"after,omitempty"`
	Before  *string            `json:"before,omitempty"`
	First   *int32             `json:"first,omitempty"`
	Last    *int32             `json:"last,omitempty"`
}

func (client *Client) Assets(params *AssetsParams) *AssetExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"AssetWhereInput", "AssetOrderByInput", "Asset"},
		"assets",
		[]string{"id", "name", "uuid", "path", "note", "mimeType"})

	return &AssetExecArray{ret}
}

type AssetsConnectionParams struct {
	Where   *AssetWhereInput   `json:"where,omitempty"`
	OrderBy *AssetOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32             `json:"skip,omitempty"`
	After   *string            `json:"after,omitempty"`
	Before  *string            `json:"before,omitempty"`
	First   *int32             `json:"first,omitempty"`
	Last    *int32             `json:"last,omitempty"`
}

func (client *Client) AssetsConnection(params *AssetsConnectionParams) AssetConnectionExec {
	panic("not implemented")
}

func (client *Client) Folio(params FolioWhereUniqueInput) *FolioExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"FolioWhereUniqueInput!", "Folio"},
		"folio",
		[]string{"id", "name", "desc"})

	return &FolioExec{ret}
}

type FoliosParams struct {
	Where   *FolioWhereInput   `json:"where,omitempty"`
	OrderBy *FolioOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32             `json:"skip,omitempty"`
	After   *string            `json:"after,omitempty"`
	Before  *string            `json:"before,omitempty"`
	First   *int32             `json:"first,omitempty"`
	Last    *int32             `json:"last,omitempty"`
}

func (client *Client) Folios(params *FoliosParams) *FolioExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"FolioWhereInput", "FolioOrderByInput", "Folio"},
		"folios",
		[]string{"id", "name", "desc"})

	return &FolioExecArray{ret}
}

type FoliosConnectionParams struct {
	Where   *FolioWhereInput   `json:"where,omitempty"`
	OrderBy *FolioOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32             `json:"skip,omitempty"`
	After   *string            `json:"after,omitempty"`
	Before  *string            `json:"before,omitempty"`
	First   *int32             `json:"first,omitempty"`
	Last    *int32             `json:"last,omitempty"`
}

func (client *Client) FoliosConnection(params *FoliosConnectionParams) FolioConnectionExec {
	panic("not implemented")
}

func (client *Client) Link(params LinkWhereUniqueInput) *LinkExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"LinkWhereUniqueInput!", "Link"},
		"link",
		[]string{"id", "name", "desc", "url"})

	return &LinkExec{ret}
}

type LinksParams struct {
	Where   *LinkWhereInput   `json:"where,omitempty"`
	OrderBy *LinkOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

func (client *Client) Links(params *LinksParams) *LinkExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"LinkWhereInput", "LinkOrderByInput", "Link"},
		"links",
		[]string{"id", "name", "desc", "url"})

	return &LinkExecArray{ret}
}

type LinksConnectionParams struct {
	Where   *LinkWhereInput   `json:"where,omitempty"`
	OrderBy *LinkOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

func (client *Client) LinksConnection(params *LinksConnectionParams) LinkConnectionExec {
	panic("not implemented")
}

func (client *Client) Note(params NoteWhereUniqueInput) *NoteExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"NoteWhereUniqueInput!", "Note"},
		"note",
		[]string{"id", "name", "note"})

	return &NoteExec{ret}
}

type NotesParams struct {
	Where   *NoteWhereInput   `json:"where,omitempty"`
	OrderBy *NoteOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

func (client *Client) Notes(params *NotesParams) *NoteExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"NoteWhereInput", "NoteOrderByInput", "Note"},
		"notes",
		[]string{"id", "name", "note"})

	return &NoteExecArray{ret}
}

type NotesConnectionParams struct {
	Where   *NoteWhereInput   `json:"where,omitempty"`
	OrderBy *NoteOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

func (client *Client) NotesConnection(params *NotesConnectionParams) NoteConnectionExec {
	panic("not implemented")
}

func (client *Client) Post(params PostWhereUniqueInput) *PostExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"PostWhereUniqueInput!", "Post"},
		"post",
		[]string{"id", "title", "published"})

	return &PostExec{ret}
}

type PostsParams struct {
	Where   *PostWhereInput   `json:"where,omitempty"`
	OrderBy *PostOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

func (client *Client) Posts(params *PostsParams) *PostExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"PostWhereInput", "PostOrderByInput", "Post"},
		"posts",
		[]string{"id", "title", "published"})

	return &PostExecArray{ret}
}

type PostsConnectionParams struct {
	Where   *PostWhereInput   `json:"where,omitempty"`
	OrderBy *PostOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

func (client *Client) PostsConnection(params *PostsConnectionParams) PostConnectionExec {
	panic("not implemented")
}

func (client *Client) Share(params ShareWhereUniqueInput) *ShareExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"ShareWhereUniqueInput!", "Share"},
		"share",
		[]string{"id"})

	return &ShareExec{ret}
}

type SharesParams struct {
	Where   *ShareWhereInput   `json:"where,omitempty"`
	OrderBy *ShareOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32             `json:"skip,omitempty"`
	After   *string            `json:"after,omitempty"`
	Before  *string            `json:"before,omitempty"`
	First   *int32             `json:"first,omitempty"`
	Last    *int32             `json:"last,omitempty"`
}

func (client *Client) Shares(params *SharesParams) *ShareExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"ShareWhereInput", "ShareOrderByInput", "Share"},
		"shares",
		[]string{"id"})

	return &ShareExecArray{ret}
}

type SharesConnectionParams struct {
	Where   *ShareWhereInput   `json:"where,omitempty"`
	OrderBy *ShareOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32             `json:"skip,omitempty"`
	After   *string            `json:"after,omitempty"`
	Before  *string            `json:"before,omitempty"`
	First   *int32             `json:"first,omitempty"`
	Last    *int32             `json:"last,omitempty"`
}

func (client *Client) SharesConnection(params *SharesConnectionParams) ShareConnectionExec {
	panic("not implemented")
}

func (client *Client) Tag(params TagWhereUniqueInput) *TagExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"TagWhereUniqueInput!", "Tag"},
		"tag",
		[]string{"id", "kind", "name", "desc"})

	return &TagExec{ret}
}

type TagsParams struct {
	Where   *TagWhereInput   `json:"where,omitempty"`
	OrderBy *TagOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32           `json:"skip,omitempty"`
	After   *string          `json:"after,omitempty"`
	Before  *string          `json:"before,omitempty"`
	First   *int32           `json:"first,omitempty"`
	Last    *int32           `json:"last,omitempty"`
}

func (client *Client) Tags(params *TagsParams) *TagExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"TagWhereInput", "TagOrderByInput", "Tag"},
		"tags",
		[]string{"id", "kind", "name", "desc"})

	return &TagExecArray{ret}
}

type TagsConnectionParams struct {
	Where   *TagWhereInput   `json:"where,omitempty"`
	OrderBy *TagOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32           `json:"skip,omitempty"`
	After   *string          `json:"after,omitempty"`
	Before  *string          `json:"before,omitempty"`
	First   *int32           `json:"first,omitempty"`
	Last    *int32           `json:"last,omitempty"`
}

func (client *Client) TagsConnection(params *TagsConnectionParams) TagConnectionExec {
	panic("not implemented")
}

func (client *Client) Thumbnail(params ThumbnailWhereUniqueInput) *ThumbnailExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"ThumbnailWhereUniqueInput!", "Thumbnail"},
		"thumbnail",
		[]string{"id", "name", "path"})

	return &ThumbnailExec{ret}
}

type ThumbnailsParams struct {
	Where   *ThumbnailWhereInput   `json:"where,omitempty"`
	OrderBy *ThumbnailOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                 `json:"skip,omitempty"`
	After   *string                `json:"after,omitempty"`
	Before  *string                `json:"before,omitempty"`
	First   *int32                 `json:"first,omitempty"`
	Last    *int32                 `json:"last,omitempty"`
}

func (client *Client) Thumbnails(params *ThumbnailsParams) *ThumbnailExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"ThumbnailWhereInput", "ThumbnailOrderByInput", "Thumbnail"},
		"thumbnails",
		[]string{"id", "name", "path"})

	return &ThumbnailExecArray{ret}
}

type ThumbnailsConnectionParams struct {
	Where   *ThumbnailWhereInput   `json:"where,omitempty"`
	OrderBy *ThumbnailOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                 `json:"skip,omitempty"`
	After   *string                `json:"after,omitempty"`
	Before  *string                `json:"before,omitempty"`
	First   *int32                 `json:"first,omitempty"`
	Last    *int32                 `json:"last,omitempty"`
}

func (client *Client) ThumbnailsConnection(params *ThumbnailsConnectionParams) ThumbnailConnectionExec {
	panic("not implemented")
}

func (client *Client) User(params UserWhereUniqueInput) *UserExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"UserWhereUniqueInput!", "User"},
		"user",
		[]string{"id", "email", "firstname", "lastname"})

	return &UserExec{ret}
}

type UsersParams struct {
	Where   *UserWhereInput   `json:"where,omitempty"`
	OrderBy *UserOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

func (client *Client) Users(params *UsersParams) *UserExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"UserWhereInput", "UserOrderByInput", "User"},
		"users",
		[]string{"id", "email", "firstname", "lastname"})

	return &UserExecArray{ret}
}

type UsersConnectionParams struct {
	Where   *UserWhereInput   `json:"where,omitempty"`
	OrderBy *UserOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

func (client *Client) UsersConnection(params *UsersConnectionParams) UserConnectionExec {
	panic("not implemented")
}

func (client *Client) CreateAsset(params AssetCreateInput) *AssetExec {
	ret := client.Client.Create(
		params,
		[2]string{"AssetCreateInput!", "Asset"},
		"createAsset",
		[]string{"id", "name", "uuid", "path", "note", "mimeType"})

	return &AssetExec{ret}
}

type AssetUpdateParams struct {
	Data  AssetUpdateInput      `json:"data"`
	Where AssetWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateAsset(params AssetUpdateParams) *AssetExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"AssetUpdateInput!", "AssetWhereUniqueInput!", "Asset"},
		"updateAsset",
		[]string{"id", "name", "uuid", "path", "note", "mimeType"})

	return &AssetExec{ret}
}

type AssetUpdateManyParams struct {
	Data  AssetUpdateManyMutationInput `json:"data"`
	Where *AssetWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyAssets(params AssetUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"AssetUpdateManyMutationInput!", "AssetWhereInput"},
		"updateManyAssets")
	return &BatchPayloadExec{exec}
}

type AssetUpsertParams struct {
	Where  AssetWhereUniqueInput `json:"where"`
	Create AssetCreateInput      `json:"create"`
	Update AssetUpdateInput      `json:"update"`
}

func (client *Client) UpsertAsset(params AssetUpsertParams) *AssetExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"AssetWhereUniqueInput!", "AssetCreateInput!", "AssetUpdateInput!", "Asset"},
		"upsertAsset",
		[]string{"id", "name", "uuid", "path", "note", "mimeType"})

	return &AssetExec{ret}
}

func (client *Client) DeleteAsset(params AssetWhereUniqueInput) *AssetExec {
	ret := client.Client.Delete(
		params,
		[2]string{"AssetWhereUniqueInput!", "Asset"},
		"deleteAsset",
		[]string{"id", "name", "uuid", "path", "note", "mimeType"})

	return &AssetExec{ret}
}

func (client *Client) DeleteManyAssets(params *AssetWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "AssetWhereInput", "deleteManyAssets")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateFolio(params FolioCreateInput) *FolioExec {
	ret := client.Client.Create(
		params,
		[2]string{"FolioCreateInput!", "Folio"},
		"createFolio",
		[]string{"id", "name", "desc"})

	return &FolioExec{ret}
}

type FolioUpdateParams struct {
	Data  FolioUpdateInput      `json:"data"`
	Where FolioWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateFolio(params FolioUpdateParams) *FolioExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"FolioUpdateInput!", "FolioWhereUniqueInput!", "Folio"},
		"updateFolio",
		[]string{"id", "name", "desc"})

	return &FolioExec{ret}
}

type FolioUpdateManyParams struct {
	Data  FolioUpdateManyMutationInput `json:"data"`
	Where *FolioWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyFolios(params FolioUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"FolioUpdateManyMutationInput!", "FolioWhereInput"},
		"updateManyFolios")
	return &BatchPayloadExec{exec}
}

type FolioUpsertParams struct {
	Where  FolioWhereUniqueInput `json:"where"`
	Create FolioCreateInput      `json:"create"`
	Update FolioUpdateInput      `json:"update"`
}

func (client *Client) UpsertFolio(params FolioUpsertParams) *FolioExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"FolioWhereUniqueInput!", "FolioCreateInput!", "FolioUpdateInput!", "Folio"},
		"upsertFolio",
		[]string{"id", "name", "desc"})

	return &FolioExec{ret}
}

func (client *Client) DeleteFolio(params FolioWhereUniqueInput) *FolioExec {
	ret := client.Client.Delete(
		params,
		[2]string{"FolioWhereUniqueInput!", "Folio"},
		"deleteFolio",
		[]string{"id", "name", "desc"})

	return &FolioExec{ret}
}

func (client *Client) DeleteManyFolios(params *FolioWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "FolioWhereInput", "deleteManyFolios")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateLink(params LinkCreateInput) *LinkExec {
	ret := client.Client.Create(
		params,
		[2]string{"LinkCreateInput!", "Link"},
		"createLink",
		[]string{"id", "name", "desc", "url"})

	return &LinkExec{ret}
}

type LinkUpdateParams struct {
	Data  LinkUpdateInput      `json:"data"`
	Where LinkWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateLink(params LinkUpdateParams) *LinkExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"LinkUpdateInput!", "LinkWhereUniqueInput!", "Link"},
		"updateLink",
		[]string{"id", "name", "desc", "url"})

	return &LinkExec{ret}
}

type LinkUpdateManyParams struct {
	Data  LinkUpdateManyMutationInput `json:"data"`
	Where *LinkWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyLinks(params LinkUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"LinkUpdateManyMutationInput!", "LinkWhereInput"},
		"updateManyLinks")
	return &BatchPayloadExec{exec}
}

type LinkUpsertParams struct {
	Where  LinkWhereUniqueInput `json:"where"`
	Create LinkCreateInput      `json:"create"`
	Update LinkUpdateInput      `json:"update"`
}

func (client *Client) UpsertLink(params LinkUpsertParams) *LinkExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"LinkWhereUniqueInput!", "LinkCreateInput!", "LinkUpdateInput!", "Link"},
		"upsertLink",
		[]string{"id", "name", "desc", "url"})

	return &LinkExec{ret}
}

func (client *Client) DeleteLink(params LinkWhereUniqueInput) *LinkExec {
	ret := client.Client.Delete(
		params,
		[2]string{"LinkWhereUniqueInput!", "Link"},
		"deleteLink",
		[]string{"id", "name", "desc", "url"})

	return &LinkExec{ret}
}

func (client *Client) DeleteManyLinks(params *LinkWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "LinkWhereInput", "deleteManyLinks")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateNote(params NoteCreateInput) *NoteExec {
	ret := client.Client.Create(
		params,
		[2]string{"NoteCreateInput!", "Note"},
		"createNote",
		[]string{"id", "name", "note"})

	return &NoteExec{ret}
}

type NoteUpdateParams struct {
	Data  NoteUpdateInput      `json:"data"`
	Where NoteWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateNote(params NoteUpdateParams) *NoteExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"NoteUpdateInput!", "NoteWhereUniqueInput!", "Note"},
		"updateNote",
		[]string{"id", "name", "note"})

	return &NoteExec{ret}
}

type NoteUpdateManyParams struct {
	Data  NoteUpdateManyMutationInput `json:"data"`
	Where *NoteWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyNotes(params NoteUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"NoteUpdateManyMutationInput!", "NoteWhereInput"},
		"updateManyNotes")
	return &BatchPayloadExec{exec}
}

type NoteUpsertParams struct {
	Where  NoteWhereUniqueInput `json:"where"`
	Create NoteCreateInput      `json:"create"`
	Update NoteUpdateInput      `json:"update"`
}

func (client *Client) UpsertNote(params NoteUpsertParams) *NoteExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"NoteWhereUniqueInput!", "NoteCreateInput!", "NoteUpdateInput!", "Note"},
		"upsertNote",
		[]string{"id", "name", "note"})

	return &NoteExec{ret}
}

func (client *Client) DeleteNote(params NoteWhereUniqueInput) *NoteExec {
	ret := client.Client.Delete(
		params,
		[2]string{"NoteWhereUniqueInput!", "Note"},
		"deleteNote",
		[]string{"id", "name", "note"})

	return &NoteExec{ret}
}

func (client *Client) DeleteManyNotes(params *NoteWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "NoteWhereInput", "deleteManyNotes")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreatePost(params PostCreateInput) *PostExec {
	ret := client.Client.Create(
		params,
		[2]string{"PostCreateInput!", "Post"},
		"createPost",
		[]string{"id", "title", "published"})

	return &PostExec{ret}
}

type PostUpdateParams struct {
	Data  PostUpdateInput      `json:"data"`
	Where PostWhereUniqueInput `json:"where"`
}

func (client *Client) UpdatePost(params PostUpdateParams) *PostExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"PostUpdateInput!", "PostWhereUniqueInput!", "Post"},
		"updatePost",
		[]string{"id", "title", "published"})

	return &PostExec{ret}
}

type PostUpdateManyParams struct {
	Data  PostUpdateManyMutationInput `json:"data"`
	Where *PostWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyPosts(params PostUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"PostUpdateManyMutationInput!", "PostWhereInput"},
		"updateManyPosts")
	return &BatchPayloadExec{exec}
}

type PostUpsertParams struct {
	Where  PostWhereUniqueInput `json:"where"`
	Create PostCreateInput      `json:"create"`
	Update PostUpdateInput      `json:"update"`
}

func (client *Client) UpsertPost(params PostUpsertParams) *PostExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"PostWhereUniqueInput!", "PostCreateInput!", "PostUpdateInput!", "Post"},
		"upsertPost",
		[]string{"id", "title", "published"})

	return &PostExec{ret}
}

func (client *Client) DeletePost(params PostWhereUniqueInput) *PostExec {
	ret := client.Client.Delete(
		params,
		[2]string{"PostWhereUniqueInput!", "Post"},
		"deletePost",
		[]string{"id", "title", "published"})

	return &PostExec{ret}
}

func (client *Client) DeleteManyPosts(params *PostWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "PostWhereInput", "deleteManyPosts")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateShare(params ShareCreateInput) *ShareExec {
	ret := client.Client.Create(
		params,
		[2]string{"ShareCreateInput!", "Share"},
		"createShare",
		[]string{"id"})

	return &ShareExec{ret}
}

type ShareUpdateParams struct {
	Data  ShareUpdateInput      `json:"data"`
	Where ShareWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateShare(params ShareUpdateParams) *ShareExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"ShareUpdateInput!", "ShareWhereUniqueInput!", "Share"},
		"updateShare",
		[]string{"id"})

	return &ShareExec{ret}
}

type ShareUpsertParams struct {
	Where  ShareWhereUniqueInput `json:"where"`
	Create ShareCreateInput      `json:"create"`
	Update ShareUpdateInput      `json:"update"`
}

func (client *Client) UpsertShare(params ShareUpsertParams) *ShareExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"ShareWhereUniqueInput!", "ShareCreateInput!", "ShareUpdateInput!", "Share"},
		"upsertShare",
		[]string{"id"})

	return &ShareExec{ret}
}

func (client *Client) DeleteShare(params ShareWhereUniqueInput) *ShareExec {
	ret := client.Client.Delete(
		params,
		[2]string{"ShareWhereUniqueInput!", "Share"},
		"deleteShare",
		[]string{"id"})

	return &ShareExec{ret}
}

func (client *Client) DeleteManyShares(params *ShareWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "ShareWhereInput", "deleteManyShares")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateTag(params TagCreateInput) *TagExec {
	ret := client.Client.Create(
		params,
		[2]string{"TagCreateInput!", "Tag"},
		"createTag",
		[]string{"id", "kind", "name", "desc"})

	return &TagExec{ret}
}

type TagUpdateParams struct {
	Data  TagUpdateInput      `json:"data"`
	Where TagWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateTag(params TagUpdateParams) *TagExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"TagUpdateInput!", "TagWhereUniqueInput!", "Tag"},
		"updateTag",
		[]string{"id", "kind", "name", "desc"})

	return &TagExec{ret}
}

type TagUpdateManyParams struct {
	Data  TagUpdateManyMutationInput `json:"data"`
	Where *TagWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyTags(params TagUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"TagUpdateManyMutationInput!", "TagWhereInput"},
		"updateManyTags")
	return &BatchPayloadExec{exec}
}

type TagUpsertParams struct {
	Where  TagWhereUniqueInput `json:"where"`
	Create TagCreateInput      `json:"create"`
	Update TagUpdateInput      `json:"update"`
}

func (client *Client) UpsertTag(params TagUpsertParams) *TagExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"TagWhereUniqueInput!", "TagCreateInput!", "TagUpdateInput!", "Tag"},
		"upsertTag",
		[]string{"id", "kind", "name", "desc"})

	return &TagExec{ret}
}

func (client *Client) DeleteTag(params TagWhereUniqueInput) *TagExec {
	ret := client.Client.Delete(
		params,
		[2]string{"TagWhereUniqueInput!", "Tag"},
		"deleteTag",
		[]string{"id", "kind", "name", "desc"})

	return &TagExec{ret}
}

func (client *Client) DeleteManyTags(params *TagWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "TagWhereInput", "deleteManyTags")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateThumbnail(params ThumbnailCreateInput) *ThumbnailExec {
	ret := client.Client.Create(
		params,
		[2]string{"ThumbnailCreateInput!", "Thumbnail"},
		"createThumbnail",
		[]string{"id", "name", "path"})

	return &ThumbnailExec{ret}
}

type ThumbnailUpdateParams struct {
	Data  ThumbnailUpdateInput      `json:"data"`
	Where ThumbnailWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateThumbnail(params ThumbnailUpdateParams) *ThumbnailExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"ThumbnailUpdateInput!", "ThumbnailWhereUniqueInput!", "Thumbnail"},
		"updateThumbnail",
		[]string{"id", "name", "path"})

	return &ThumbnailExec{ret}
}

type ThumbnailUpdateManyParams struct {
	Data  ThumbnailUpdateManyMutationInput `json:"data"`
	Where *ThumbnailWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyThumbnails(params ThumbnailUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"ThumbnailUpdateManyMutationInput!", "ThumbnailWhereInput"},
		"updateManyThumbnails")
	return &BatchPayloadExec{exec}
}

type ThumbnailUpsertParams struct {
	Where  ThumbnailWhereUniqueInput `json:"where"`
	Create ThumbnailCreateInput      `json:"create"`
	Update ThumbnailUpdateInput      `json:"update"`
}

func (client *Client) UpsertThumbnail(params ThumbnailUpsertParams) *ThumbnailExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"ThumbnailWhereUniqueInput!", "ThumbnailCreateInput!", "ThumbnailUpdateInput!", "Thumbnail"},
		"upsertThumbnail",
		[]string{"id", "name", "path"})

	return &ThumbnailExec{ret}
}

func (client *Client) DeleteThumbnail(params ThumbnailWhereUniqueInput) *ThumbnailExec {
	ret := client.Client.Delete(
		params,
		[2]string{"ThumbnailWhereUniqueInput!", "Thumbnail"},
		"deleteThumbnail",
		[]string{"id", "name", "path"})

	return &ThumbnailExec{ret}
}

func (client *Client) DeleteManyThumbnails(params *ThumbnailWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "ThumbnailWhereInput", "deleteManyThumbnails")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateUser(params UserCreateInput) *UserExec {
	ret := client.Client.Create(
		params,
		[2]string{"UserCreateInput!", "User"},
		"createUser",
		[]string{"id", "email", "firstname", "lastname"})

	return &UserExec{ret}
}

type UserUpdateParams struct {
	Data  UserUpdateInput      `json:"data"`
	Where UserWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateUser(params UserUpdateParams) *UserExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"UserUpdateInput!", "UserWhereUniqueInput!", "User"},
		"updateUser",
		[]string{"id", "email", "firstname", "lastname"})

	return &UserExec{ret}
}

type UserUpdateManyParams struct {
	Data  UserUpdateManyMutationInput `json:"data"`
	Where *UserWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyUsers(params UserUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"UserUpdateManyMutationInput!", "UserWhereInput"},
		"updateManyUsers")
	return &BatchPayloadExec{exec}
}

type UserUpsertParams struct {
	Where  UserWhereUniqueInput `json:"where"`
	Create UserCreateInput      `json:"create"`
	Update UserUpdateInput      `json:"update"`
}

func (client *Client) UpsertUser(params UserUpsertParams) *UserExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"UserWhereUniqueInput!", "UserCreateInput!", "UserUpdateInput!", "User"},
		"upsertUser",
		[]string{"id", "email", "firstname", "lastname"})

	return &UserExec{ret}
}

func (client *Client) DeleteUser(params UserWhereUniqueInput) *UserExec {
	ret := client.Client.Delete(
		params,
		[2]string{"UserWhereUniqueInput!", "User"},
		"deleteUser",
		[]string{"id", "email", "firstname", "lastname"})

	return &UserExec{ret}
}

func (client *Client) DeleteManyUsers(params *UserWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "UserWhereInput", "deleteManyUsers")
	return &BatchPayloadExec{exec}
}

type TagOrderByInput string

const (
	TagOrderByInputIDAsc         TagOrderByInput = "id_ASC"
	TagOrderByInputIDDesc        TagOrderByInput = "id_DESC"
	TagOrderByInputKindAsc       TagOrderByInput = "kind_ASC"
	TagOrderByInputKindDesc      TagOrderByInput = "kind_DESC"
	TagOrderByInputNameAsc       TagOrderByInput = "name_ASC"
	TagOrderByInputNameDesc      TagOrderByInput = "name_DESC"
	TagOrderByInputDescAsc       TagOrderByInput = "desc_ASC"
	TagOrderByInputDescDesc      TagOrderByInput = "desc_DESC"
	TagOrderByInputCreatedAtAsc  TagOrderByInput = "createdAt_ASC"
	TagOrderByInputCreatedAtDesc TagOrderByInput = "createdAt_DESC"
	TagOrderByInputUpdatedAtAsc  TagOrderByInput = "updatedAt_ASC"
	TagOrderByInputUpdatedAtDesc TagOrderByInput = "updatedAt_DESC"
)

type TagType string

const (
	TagTypePerson   TagType = "Person"
	TagTypePlace    TagType = "Place"
	TagTypeThing    TagType = "Thing"
	TagTypeFolder   TagType = "Folder"
	TagTypeTag      TagType = "Tag"
	TagTypeCategory TagType = "Category"
)

type AssetOrderByInput string

const (
	AssetOrderByInputIDAsc         AssetOrderByInput = "id_ASC"
	AssetOrderByInputIDDesc        AssetOrderByInput = "id_DESC"
	AssetOrderByInputNameAsc       AssetOrderByInput = "name_ASC"
	AssetOrderByInputNameDesc      AssetOrderByInput = "name_DESC"
	AssetOrderByInputUuidAsc       AssetOrderByInput = "uuid_ASC"
	AssetOrderByInputUuidDesc      AssetOrderByInput = "uuid_DESC"
	AssetOrderByInputPathAsc       AssetOrderByInput = "path_ASC"
	AssetOrderByInputPathDesc      AssetOrderByInput = "path_DESC"
	AssetOrderByInputNoteAsc       AssetOrderByInput = "note_ASC"
	AssetOrderByInputNoteDesc      AssetOrderByInput = "note_DESC"
	AssetOrderByInputMimeTypeAsc   AssetOrderByInput = "mimeType_ASC"
	AssetOrderByInputMimeTypeDesc  AssetOrderByInput = "mimeType_DESC"
	AssetOrderByInputCreatedAtAsc  AssetOrderByInput = "createdAt_ASC"
	AssetOrderByInputCreatedAtDesc AssetOrderByInput = "createdAt_DESC"
	AssetOrderByInputUpdatedAtAsc  AssetOrderByInput = "updatedAt_ASC"
	AssetOrderByInputUpdatedAtDesc AssetOrderByInput = "updatedAt_DESC"
)

type LinkOrderByInput string

const (
	LinkOrderByInputIDAsc         LinkOrderByInput = "id_ASC"
	LinkOrderByInputIDDesc        LinkOrderByInput = "id_DESC"
	LinkOrderByInputNameAsc       LinkOrderByInput = "name_ASC"
	LinkOrderByInputNameDesc      LinkOrderByInput = "name_DESC"
	LinkOrderByInputDescAsc       LinkOrderByInput = "desc_ASC"
	LinkOrderByInputDescDesc      LinkOrderByInput = "desc_DESC"
	LinkOrderByInputUrlAsc        LinkOrderByInput = "url_ASC"
	LinkOrderByInputUrlDesc       LinkOrderByInput = "url_DESC"
	LinkOrderByInputCreatedAtAsc  LinkOrderByInput = "createdAt_ASC"
	LinkOrderByInputCreatedAtDesc LinkOrderByInput = "createdAt_DESC"
	LinkOrderByInputUpdatedAtAsc  LinkOrderByInput = "updatedAt_ASC"
	LinkOrderByInputUpdatedAtDesc LinkOrderByInput = "updatedAt_DESC"
)

type NoteOrderByInput string

const (
	NoteOrderByInputIDAsc         NoteOrderByInput = "id_ASC"
	NoteOrderByInputIDDesc        NoteOrderByInput = "id_DESC"
	NoteOrderByInputNameAsc       NoteOrderByInput = "name_ASC"
	NoteOrderByInputNameDesc      NoteOrderByInput = "name_DESC"
	NoteOrderByInputNoteAsc       NoteOrderByInput = "note_ASC"
	NoteOrderByInputNoteDesc      NoteOrderByInput = "note_DESC"
	NoteOrderByInputCreatedAtAsc  NoteOrderByInput = "createdAt_ASC"
	NoteOrderByInputCreatedAtDesc NoteOrderByInput = "createdAt_DESC"
	NoteOrderByInputUpdatedAtAsc  NoteOrderByInput = "updatedAt_ASC"
	NoteOrderByInputUpdatedAtDesc NoteOrderByInput = "updatedAt_DESC"
)

type PostOrderByInput string

const (
	PostOrderByInputIDAsc         PostOrderByInput = "id_ASC"
	PostOrderByInputIDDesc        PostOrderByInput = "id_DESC"
	PostOrderByInputTitleAsc      PostOrderByInput = "title_ASC"
	PostOrderByInputTitleDesc     PostOrderByInput = "title_DESC"
	PostOrderByInputPublishedAsc  PostOrderByInput = "published_ASC"
	PostOrderByInputPublishedDesc PostOrderByInput = "published_DESC"
	PostOrderByInputCreatedAtAsc  PostOrderByInput = "createdAt_ASC"
	PostOrderByInputCreatedAtDesc PostOrderByInput = "createdAt_DESC"
	PostOrderByInputUpdatedAtAsc  PostOrderByInput = "updatedAt_ASC"
	PostOrderByInputUpdatedAtDesc PostOrderByInput = "updatedAt_DESC"
)

type MutationType string

const (
	MutationTypeCreated MutationType = "CREATED"
	MutationTypeUpdated MutationType = "UPDATED"
	MutationTypeDeleted MutationType = "DELETED"
)

type FolioOrderByInput string

const (
	FolioOrderByInputIDAsc         FolioOrderByInput = "id_ASC"
	FolioOrderByInputIDDesc        FolioOrderByInput = "id_DESC"
	FolioOrderByInputNameAsc       FolioOrderByInput = "name_ASC"
	FolioOrderByInputNameDesc      FolioOrderByInput = "name_DESC"
	FolioOrderByInputDescAsc       FolioOrderByInput = "desc_ASC"
	FolioOrderByInputDescDesc      FolioOrderByInput = "desc_DESC"
	FolioOrderByInputCreatedAtAsc  FolioOrderByInput = "createdAt_ASC"
	FolioOrderByInputCreatedAtDesc FolioOrderByInput = "createdAt_DESC"
	FolioOrderByInputUpdatedAtAsc  FolioOrderByInput = "updatedAt_ASC"
	FolioOrderByInputUpdatedAtDesc FolioOrderByInput = "updatedAt_DESC"
)

type ShareOrderByInput string

const (
	ShareOrderByInputIDAsc         ShareOrderByInput = "id_ASC"
	ShareOrderByInputIDDesc        ShareOrderByInput = "id_DESC"
	ShareOrderByInputCreatedAtAsc  ShareOrderByInput = "createdAt_ASC"
	ShareOrderByInputCreatedAtDesc ShareOrderByInput = "createdAt_DESC"
	ShareOrderByInputUpdatedAtAsc  ShareOrderByInput = "updatedAt_ASC"
	ShareOrderByInputUpdatedAtDesc ShareOrderByInput = "updatedAt_DESC"
)

type ThumbnailOrderByInput string

const (
	ThumbnailOrderByInputIDAsc         ThumbnailOrderByInput = "id_ASC"
	ThumbnailOrderByInputIDDesc        ThumbnailOrderByInput = "id_DESC"
	ThumbnailOrderByInputNameAsc       ThumbnailOrderByInput = "name_ASC"
	ThumbnailOrderByInputNameDesc      ThumbnailOrderByInput = "name_DESC"
	ThumbnailOrderByInputPathAsc       ThumbnailOrderByInput = "path_ASC"
	ThumbnailOrderByInputPathDesc      ThumbnailOrderByInput = "path_DESC"
	ThumbnailOrderByInputCreatedAtAsc  ThumbnailOrderByInput = "createdAt_ASC"
	ThumbnailOrderByInputCreatedAtDesc ThumbnailOrderByInput = "createdAt_DESC"
	ThumbnailOrderByInputUpdatedAtAsc  ThumbnailOrderByInput = "updatedAt_ASC"
	ThumbnailOrderByInputUpdatedAtDesc ThumbnailOrderByInput = "updatedAt_DESC"
)

type UserOrderByInput string

const (
	UserOrderByInputIDAsc         UserOrderByInput = "id_ASC"
	UserOrderByInputIDDesc        UserOrderByInput = "id_DESC"
	UserOrderByInputEmailAsc      UserOrderByInput = "email_ASC"
	UserOrderByInputEmailDesc     UserOrderByInput = "email_DESC"
	UserOrderByInputFirstnameAsc  UserOrderByInput = "firstname_ASC"
	UserOrderByInputFirstnameDesc UserOrderByInput = "firstname_DESC"
	UserOrderByInputLastnameAsc   UserOrderByInput = "lastname_ASC"
	UserOrderByInputLastnameDesc  UserOrderByInput = "lastname_DESC"
	UserOrderByInputCreatedAtAsc  UserOrderByInput = "createdAt_ASC"
	UserOrderByInputCreatedAtDesc UserOrderByInput = "createdAt_DESC"
	UserOrderByInputUpdatedAtAsc  UserOrderByInput = "updatedAt_ASC"
	UserOrderByInputUpdatedAtDesc UserOrderByInput = "updatedAt_DESC"
)

type PostUpdateWithWhereUniqueWithoutAuthorInput struct {
	Where PostWhereUniqueInput             `json:"where"`
	Data  PostUpdateWithoutAuthorDataInput `json:"data"`
}

type AssetWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type AssetUpdateInput struct {
	Name      *string                           `json:"name,omitempty"`
	Uuid      *string                           `json:"uuid,omitempty"`
	Path      *string                           `json:"path,omitempty"`
	Note      *string                           `json:"note,omitempty"`
	MimeType  *string                           `json:"mimeType,omitempty"`
	Thumbnail *ThumbnailUpdateOneInput          `json:"thumbnail,omitempty"`
	Folio     *FolioUpdateOneWithoutAssetsInput `json:"folio,omitempty"`
}

type NoteUpdateManyMutationInput struct {
	Name *string `json:"name,omitempty"`
	Note *string `json:"note,omitempty"`
}

type ThumbnailUpdateOneInput struct {
	Create     *ThumbnailCreateInput       `json:"create,omitempty"`
	Update     *ThumbnailUpdateDataInput   `json:"update,omitempty"`
	Upsert     *ThumbnailUpsertNestedInput `json:"upsert,omitempty"`
	Delete     *bool                       `json:"delete,omitempty"`
	Disconnect *bool                       `json:"disconnect,omitempty"`
	Connect    *ThumbnailWhereUniqueInput  `json:"connect,omitempty"`
}

type TagUpdateManyWithoutFoliosInput struct {
	Create     []TagCreateWithoutFoliosInput                `json:"create,omitempty"`
	Delete     []TagWhereUniqueInput                        `json:"delete,omitempty"`
	Connect    []TagWhereUniqueInput                        `json:"connect,omitempty"`
	Set        []TagWhereUniqueInput                        `json:"set,omitempty"`
	Disconnect []TagWhereUniqueInput                        `json:"disconnect,omitempty"`
	Update     []TagUpdateWithWhereUniqueWithoutFoliosInput `json:"update,omitempty"`
	Upsert     []TagUpsertWithWhereUniqueWithoutFoliosInput `json:"upsert,omitempty"`
	DeleteMany []TagScalarWhereInput                        `json:"deleteMany,omitempty"`
	UpdateMany []TagUpdateManyWithWhereNestedInput          `json:"updateMany,omitempty"`
}

type ThumbnailUpdateDataInput struct {
	Name *string `json:"name,omitempty"`
	Path *string `json:"path,omitempty"`
}

type ShareWhereInput struct {
	ID              *string              `json:"id,omitempty"`
	IDNot           *string              `json:"id_not,omitempty"`
	IDIn            []string             `json:"id_in,omitempty"`
	IDNotIn         []string             `json:"id_not_in,omitempty"`
	IDLt            *string              `json:"id_lt,omitempty"`
	IDLte           *string              `json:"id_lte,omitempty"`
	IDGt            *string              `json:"id_gt,omitempty"`
	IDGte           *string              `json:"id_gte,omitempty"`
	IDContains      *string              `json:"id_contains,omitempty"`
	IDNotContains   *string              `json:"id_not_contains,omitempty"`
	IDStartsWith    *string              `json:"id_starts_with,omitempty"`
	IDNotStartsWith *string              `json:"id_not_starts_with,omitempty"`
	IDEndsWith      *string              `json:"id_ends_with,omitempty"`
	IDNotEndsWith   *string              `json:"id_not_ends_with,omitempty"`
	Owner           *UserWhereInput      `json:"owner,omitempty"`
	Friend          *UserWhereInput      `json:"friend,omitempty"`
	Thumbnail       *ThumbnailWhereInput `json:"thumbnail,omitempty"`
	FoliosEvery     *FolioWhereInput     `json:"folios_every,omitempty"`
	FoliosSome      *FolioWhereInput     `json:"folios_some,omitempty"`
	FoliosNone      *FolioWhereInput     `json:"folios_none,omitempty"`
	And             []ShareWhereInput    `json:"AND,omitempty"`
	Or              []ShareWhereInput    `json:"OR,omitempty"`
	Not             []ShareWhereInput    `json:"NOT,omitempty"`
}

type ThumbnailUpsertNestedInput struct {
	Update ThumbnailUpdateDataInput `json:"update"`
	Create ThumbnailCreateInput     `json:"create"`
}

type UserSubscriptionWhereInput struct {
	MutationIn                 []MutationType               `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                      `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                     `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                     `json:"updatedFields_contains_some,omitempty"`
	Node                       *UserWhereInput              `json:"node,omitempty"`
	And                        []UserSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []UserSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []UserSubscriptionWhereInput `json:"NOT,omitempty"`
}

type FolioUpdateOneWithoutAssetsInput struct {
	Create     *FolioCreateWithoutAssetsInput     `json:"create,omitempty"`
	Update     *FolioUpdateWithoutAssetsDataInput `json:"update,omitempty"`
	Upsert     *FolioUpsertWithoutAssetsInput     `json:"upsert,omitempty"`
	Delete     *bool                              `json:"delete,omitempty"`
	Disconnect *bool                              `json:"disconnect,omitempty"`
	Connect    *FolioWhereUniqueInput             `json:"connect,omitempty"`
}

type ThumbnailSubscriptionWhereInput struct {
	MutationIn                 []MutationType                    `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                           `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                          `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                          `json:"updatedFields_contains_some,omitempty"`
	Node                       *ThumbnailWhereInput              `json:"node,omitempty"`
	And                        []ThumbnailSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []ThumbnailSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []ThumbnailSubscriptionWhereInput `json:"NOT,omitempty"`
}

type FolioUpdateWithoutAssetsDataInput struct {
	Name      *string                            `json:"name,omitempty"`
	Desc      *string                            `json:"desc,omitempty"`
	Thumbnail *ThumbnailUpdateOneInput           `json:"thumbnail,omitempty"`
	Links     *LinkUpdateManyWithoutFolioInput   `json:"links,omitempty"`
	Notes     *NoteUpdateManyWithoutFolioInput   `json:"notes,omitempty"`
	Owner     *UserUpdateOneRequiredInput        `json:"owner,omitempty"`
	Tags      *TagUpdateManyWithoutFoliosInput   `json:"tags,omitempty"`
	Shares    *ShareUpdateManyWithoutFoliosInput `json:"shares,omitempty"`
}

type TagSubscriptionWhereInput struct {
	MutationIn                 []MutationType              `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                     `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                    `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                    `json:"updatedFields_contains_some,omitempty"`
	Node                       *TagWhereInput              `json:"node,omitempty"`
	And                        []TagSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []TagSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []TagSubscriptionWhereInput `json:"NOT,omitempty"`
}

type LinkUpdateManyWithoutFolioInput struct {
	Create     []LinkCreateWithoutFolioInput                `json:"create,omitempty"`
	Delete     []LinkWhereUniqueInput                       `json:"delete,omitempty"`
	Connect    []LinkWhereUniqueInput                       `json:"connect,omitempty"`
	Set        []LinkWhereUniqueInput                       `json:"set,omitempty"`
	Disconnect []LinkWhereUniqueInput                       `json:"disconnect,omitempty"`
	Update     []LinkUpdateWithWhereUniqueWithoutFolioInput `json:"update,omitempty"`
	Upsert     []LinkUpsertWithWhereUniqueWithoutFolioInput `json:"upsert,omitempty"`
	DeleteMany []LinkScalarWhereInput                       `json:"deleteMany,omitempty"`
	UpdateMany []LinkUpdateManyWithWhereNestedInput         `json:"updateMany,omitempty"`
}

type FolioWhereInput struct {
	ID                *string              `json:"id,omitempty"`
	IDNot             *string              `json:"id_not,omitempty"`
	IDIn              []string             `json:"id_in,omitempty"`
	IDNotIn           []string             `json:"id_not_in,omitempty"`
	IDLt              *string              `json:"id_lt,omitempty"`
	IDLte             *string              `json:"id_lte,omitempty"`
	IDGt              *string              `json:"id_gt,omitempty"`
	IDGte             *string              `json:"id_gte,omitempty"`
	IDContains        *string              `json:"id_contains,omitempty"`
	IDNotContains     *string              `json:"id_not_contains,omitempty"`
	IDStartsWith      *string              `json:"id_starts_with,omitempty"`
	IDNotStartsWith   *string              `json:"id_not_starts_with,omitempty"`
	IDEndsWith        *string              `json:"id_ends_with,omitempty"`
	IDNotEndsWith     *string              `json:"id_not_ends_with,omitempty"`
	Name              *string              `json:"name,omitempty"`
	NameNot           *string              `json:"name_not,omitempty"`
	NameIn            []string             `json:"name_in,omitempty"`
	NameNotIn         []string             `json:"name_not_in,omitempty"`
	NameLt            *string              `json:"name_lt,omitempty"`
	NameLte           *string              `json:"name_lte,omitempty"`
	NameGt            *string              `json:"name_gt,omitempty"`
	NameGte           *string              `json:"name_gte,omitempty"`
	NameContains      *string              `json:"name_contains,omitempty"`
	NameNotContains   *string              `json:"name_not_contains,omitempty"`
	NameStartsWith    *string              `json:"name_starts_with,omitempty"`
	NameNotStartsWith *string              `json:"name_not_starts_with,omitempty"`
	NameEndsWith      *string              `json:"name_ends_with,omitempty"`
	NameNotEndsWith   *string              `json:"name_not_ends_with,omitempty"`
	Desc              *string              `json:"desc,omitempty"`
	DescNot           *string              `json:"desc_not,omitempty"`
	DescIn            []string             `json:"desc_in,omitempty"`
	DescNotIn         []string             `json:"desc_not_in,omitempty"`
	DescLt            *string              `json:"desc_lt,omitempty"`
	DescLte           *string              `json:"desc_lte,omitempty"`
	DescGt            *string              `json:"desc_gt,omitempty"`
	DescGte           *string              `json:"desc_gte,omitempty"`
	DescContains      *string              `json:"desc_contains,omitempty"`
	DescNotContains   *string              `json:"desc_not_contains,omitempty"`
	DescStartsWith    *string              `json:"desc_starts_with,omitempty"`
	DescNotStartsWith *string              `json:"desc_not_starts_with,omitempty"`
	DescEndsWith      *string              `json:"desc_ends_with,omitempty"`
	DescNotEndsWith   *string              `json:"desc_not_ends_with,omitempty"`
	Thumbnail         *ThumbnailWhereInput `json:"thumbnail,omitempty"`
	AssetsEvery       *AssetWhereInput     `json:"assets_every,omitempty"`
	AssetsSome        *AssetWhereInput     `json:"assets_some,omitempty"`
	AssetsNone        *AssetWhereInput     `json:"assets_none,omitempty"`
	LinksEvery        *LinkWhereInput      `json:"links_every,omitempty"`
	LinksSome         *LinkWhereInput      `json:"links_some,omitempty"`
	LinksNone         *LinkWhereInput      `json:"links_none,omitempty"`
	NotesEvery        *NoteWhereInput      `json:"notes_every,omitempty"`
	NotesSome         *NoteWhereInput      `json:"notes_some,omitempty"`
	NotesNone         *NoteWhereInput      `json:"notes_none,omitempty"`
	Owner             *UserWhereInput      `json:"owner,omitempty"`
	TagsEvery         *TagWhereInput       `json:"tags_every,omitempty"`
	TagsSome          *TagWhereInput       `json:"tags_some,omitempty"`
	TagsNone          *TagWhereInput       `json:"tags_none,omitempty"`
	SharesEvery       *ShareWhereInput     `json:"shares_every,omitempty"`
	SharesSome        *ShareWhereInput     `json:"shares_some,omitempty"`
	SharesNone        *ShareWhereInput     `json:"shares_none,omitempty"`
	And               []FolioWhereInput    `json:"AND,omitempty"`
	Or                []FolioWhereInput    `json:"OR,omitempty"`
	Not               []FolioWhereInput    `json:"NOT,omitempty"`
}

type LinkUpdateWithWhereUniqueWithoutFolioInput struct {
	Where LinkWhereUniqueInput            `json:"where"`
	Data  LinkUpdateWithoutFolioDataInput `json:"data"`
}

type ThumbnailWhereInput struct {
	ID                *string               `json:"id,omitempty"`
	IDNot             *string               `json:"id_not,omitempty"`
	IDIn              []string              `json:"id_in,omitempty"`
	IDNotIn           []string              `json:"id_not_in,omitempty"`
	IDLt              *string               `json:"id_lt,omitempty"`
	IDLte             *string               `json:"id_lte,omitempty"`
	IDGt              *string               `json:"id_gt,omitempty"`
	IDGte             *string               `json:"id_gte,omitempty"`
	IDContains        *string               `json:"id_contains,omitempty"`
	IDNotContains     *string               `json:"id_not_contains,omitempty"`
	IDStartsWith      *string               `json:"id_starts_with,omitempty"`
	IDNotStartsWith   *string               `json:"id_not_starts_with,omitempty"`
	IDEndsWith        *string               `json:"id_ends_with,omitempty"`
	IDNotEndsWith     *string               `json:"id_not_ends_with,omitempty"`
	Name              *string               `json:"name,omitempty"`
	NameNot           *string               `json:"name_not,omitempty"`
	NameIn            []string              `json:"name_in,omitempty"`
	NameNotIn         []string              `json:"name_not_in,omitempty"`
	NameLt            *string               `json:"name_lt,omitempty"`
	NameLte           *string               `json:"name_lte,omitempty"`
	NameGt            *string               `json:"name_gt,omitempty"`
	NameGte           *string               `json:"name_gte,omitempty"`
	NameContains      *string               `json:"name_contains,omitempty"`
	NameNotContains   *string               `json:"name_not_contains,omitempty"`
	NameStartsWith    *string               `json:"name_starts_with,omitempty"`
	NameNotStartsWith *string               `json:"name_not_starts_with,omitempty"`
	NameEndsWith      *string               `json:"name_ends_with,omitempty"`
	NameNotEndsWith   *string               `json:"name_not_ends_with,omitempty"`
	Path              *string               `json:"path,omitempty"`
	PathNot           *string               `json:"path_not,omitempty"`
	PathIn            []string              `json:"path_in,omitempty"`
	PathNotIn         []string              `json:"path_not_in,omitempty"`
	PathLt            *string               `json:"path_lt,omitempty"`
	PathLte           *string               `json:"path_lte,omitempty"`
	PathGt            *string               `json:"path_gt,omitempty"`
	PathGte           *string               `json:"path_gte,omitempty"`
	PathContains      *string               `json:"path_contains,omitempty"`
	PathNotContains   *string               `json:"path_not_contains,omitempty"`
	PathStartsWith    *string               `json:"path_starts_with,omitempty"`
	PathNotStartsWith *string               `json:"path_not_starts_with,omitempty"`
	PathEndsWith      *string               `json:"path_ends_with,omitempty"`
	PathNotEndsWith   *string               `json:"path_not_ends_with,omitempty"`
	And               []ThumbnailWhereInput `json:"AND,omitempty"`
	Or                []ThumbnailWhereInput `json:"OR,omitempty"`
	Not               []ThumbnailWhereInput `json:"NOT,omitempty"`
}

type LinkUpdateWithoutFolioDataInput struct {
	Name      *string                  `json:"name,omitempty"`
	Desc      *string                  `json:"desc,omitempty"`
	Url       *string                  `json:"url,omitempty"`
	Thumbnail *ThumbnailUpdateOneInput `json:"thumbnail,omitempty"`
}

type AssetWhereInput struct {
	ID                    *string              `json:"id,omitempty"`
	IDNot                 *string              `json:"id_not,omitempty"`
	IDIn                  []string             `json:"id_in,omitempty"`
	IDNotIn               []string             `json:"id_not_in,omitempty"`
	IDLt                  *string              `json:"id_lt,omitempty"`
	IDLte                 *string              `json:"id_lte,omitempty"`
	IDGt                  *string              `json:"id_gt,omitempty"`
	IDGte                 *string              `json:"id_gte,omitempty"`
	IDContains            *string              `json:"id_contains,omitempty"`
	IDNotContains         *string              `json:"id_not_contains,omitempty"`
	IDStartsWith          *string              `json:"id_starts_with,omitempty"`
	IDNotStartsWith       *string              `json:"id_not_starts_with,omitempty"`
	IDEndsWith            *string              `json:"id_ends_with,omitempty"`
	IDNotEndsWith         *string              `json:"id_not_ends_with,omitempty"`
	Name                  *string              `json:"name,omitempty"`
	NameNot               *string              `json:"name_not,omitempty"`
	NameIn                []string             `json:"name_in,omitempty"`
	NameNotIn             []string             `json:"name_not_in,omitempty"`
	NameLt                *string              `json:"name_lt,omitempty"`
	NameLte               *string              `json:"name_lte,omitempty"`
	NameGt                *string              `json:"name_gt,omitempty"`
	NameGte               *string              `json:"name_gte,omitempty"`
	NameContains          *string              `json:"name_contains,omitempty"`
	NameNotContains       *string              `json:"name_not_contains,omitempty"`
	NameStartsWith        *string              `json:"name_starts_with,omitempty"`
	NameNotStartsWith     *string              `json:"name_not_starts_with,omitempty"`
	NameEndsWith          *string              `json:"name_ends_with,omitempty"`
	NameNotEndsWith       *string              `json:"name_not_ends_with,omitempty"`
	Uuid                  *string              `json:"uuid,omitempty"`
	UuidNot               *string              `json:"uuid_not,omitempty"`
	UuidIn                []string             `json:"uuid_in,omitempty"`
	UuidNotIn             []string             `json:"uuid_not_in,omitempty"`
	UuidLt                *string              `json:"uuid_lt,omitempty"`
	UuidLte               *string              `json:"uuid_lte,omitempty"`
	UuidGt                *string              `json:"uuid_gt,omitempty"`
	UuidGte               *string              `json:"uuid_gte,omitempty"`
	UuidContains          *string              `json:"uuid_contains,omitempty"`
	UuidNotContains       *string              `json:"uuid_not_contains,omitempty"`
	UuidStartsWith        *string              `json:"uuid_starts_with,omitempty"`
	UuidNotStartsWith     *string              `json:"uuid_not_starts_with,omitempty"`
	UuidEndsWith          *string              `json:"uuid_ends_with,omitempty"`
	UuidNotEndsWith       *string              `json:"uuid_not_ends_with,omitempty"`
	Path                  *string              `json:"path,omitempty"`
	PathNot               *string              `json:"path_not,omitempty"`
	PathIn                []string             `json:"path_in,omitempty"`
	PathNotIn             []string             `json:"path_not_in,omitempty"`
	PathLt                *string              `json:"path_lt,omitempty"`
	PathLte               *string              `json:"path_lte,omitempty"`
	PathGt                *string              `json:"path_gt,omitempty"`
	PathGte               *string              `json:"path_gte,omitempty"`
	PathContains          *string              `json:"path_contains,omitempty"`
	PathNotContains       *string              `json:"path_not_contains,omitempty"`
	PathStartsWith        *string              `json:"path_starts_with,omitempty"`
	PathNotStartsWith     *string              `json:"path_not_starts_with,omitempty"`
	PathEndsWith          *string              `json:"path_ends_with,omitempty"`
	PathNotEndsWith       *string              `json:"path_not_ends_with,omitempty"`
	Note                  *string              `json:"note,omitempty"`
	NoteNot               *string              `json:"note_not,omitempty"`
	NoteIn                []string             `json:"note_in,omitempty"`
	NoteNotIn             []string             `json:"note_not_in,omitempty"`
	NoteLt                *string              `json:"note_lt,omitempty"`
	NoteLte               *string              `json:"note_lte,omitempty"`
	NoteGt                *string              `json:"note_gt,omitempty"`
	NoteGte               *string              `json:"note_gte,omitempty"`
	NoteContains          *string              `json:"note_contains,omitempty"`
	NoteNotContains       *string              `json:"note_not_contains,omitempty"`
	NoteStartsWith        *string              `json:"note_starts_with,omitempty"`
	NoteNotStartsWith     *string              `json:"note_not_starts_with,omitempty"`
	NoteEndsWith          *string              `json:"note_ends_with,omitempty"`
	NoteNotEndsWith       *string              `json:"note_not_ends_with,omitempty"`
	MimeType              *string              `json:"mimeType,omitempty"`
	MimeTypeNot           *string              `json:"mimeType_not,omitempty"`
	MimeTypeIn            []string             `json:"mimeType_in,omitempty"`
	MimeTypeNotIn         []string             `json:"mimeType_not_in,omitempty"`
	MimeTypeLt            *string              `json:"mimeType_lt,omitempty"`
	MimeTypeLte           *string              `json:"mimeType_lte,omitempty"`
	MimeTypeGt            *string              `json:"mimeType_gt,omitempty"`
	MimeTypeGte           *string              `json:"mimeType_gte,omitempty"`
	MimeTypeContains      *string              `json:"mimeType_contains,omitempty"`
	MimeTypeNotContains   *string              `json:"mimeType_not_contains,omitempty"`
	MimeTypeStartsWith    *string              `json:"mimeType_starts_with,omitempty"`
	MimeTypeNotStartsWith *string              `json:"mimeType_not_starts_with,omitempty"`
	MimeTypeEndsWith      *string              `json:"mimeType_ends_with,omitempty"`
	MimeTypeNotEndsWith   *string              `json:"mimeType_not_ends_with,omitempty"`
	Thumbnail             *ThumbnailWhereInput `json:"thumbnail,omitempty"`
	Folio                 *FolioWhereInput     `json:"folio,omitempty"`
	And                   []AssetWhereInput    `json:"AND,omitempty"`
	Or                    []AssetWhereInput    `json:"OR,omitempty"`
	Not                   []AssetWhereInput    `json:"NOT,omitempty"`
}

type LinkUpsertWithWhereUniqueWithoutFolioInput struct {
	Where  LinkWhereUniqueInput            `json:"where"`
	Update LinkUpdateWithoutFolioDataInput `json:"update"`
	Create LinkCreateWithoutFolioInput     `json:"create"`
}

type FolioSubscriptionWhereInput struct {
	MutationIn                 []MutationType                `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                       `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                      `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                      `json:"updatedFields_contains_some,omitempty"`
	Node                       *FolioWhereInput              `json:"node,omitempty"`
	And                        []FolioSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []FolioSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []FolioSubscriptionWhereInput `json:"NOT,omitempty"`
}

type LinkScalarWhereInput struct {
	ID                *string                `json:"id,omitempty"`
	IDNot             *string                `json:"id_not,omitempty"`
	IDIn              []string               `json:"id_in,omitempty"`
	IDNotIn           []string               `json:"id_not_in,omitempty"`
	IDLt              *string                `json:"id_lt,omitempty"`
	IDLte             *string                `json:"id_lte,omitempty"`
	IDGt              *string                `json:"id_gt,omitempty"`
	IDGte             *string                `json:"id_gte,omitempty"`
	IDContains        *string                `json:"id_contains,omitempty"`
	IDNotContains     *string                `json:"id_not_contains,omitempty"`
	IDStartsWith      *string                `json:"id_starts_with,omitempty"`
	IDNotStartsWith   *string                `json:"id_not_starts_with,omitempty"`
	IDEndsWith        *string                `json:"id_ends_with,omitempty"`
	IDNotEndsWith     *string                `json:"id_not_ends_with,omitempty"`
	Name              *string                `json:"name,omitempty"`
	NameNot           *string                `json:"name_not,omitempty"`
	NameIn            []string               `json:"name_in,omitempty"`
	NameNotIn         []string               `json:"name_not_in,omitempty"`
	NameLt            *string                `json:"name_lt,omitempty"`
	NameLte           *string                `json:"name_lte,omitempty"`
	NameGt            *string                `json:"name_gt,omitempty"`
	NameGte           *string                `json:"name_gte,omitempty"`
	NameContains      *string                `json:"name_contains,omitempty"`
	NameNotContains   *string                `json:"name_not_contains,omitempty"`
	NameStartsWith    *string                `json:"name_starts_with,omitempty"`
	NameNotStartsWith *string                `json:"name_not_starts_with,omitempty"`
	NameEndsWith      *string                `json:"name_ends_with,omitempty"`
	NameNotEndsWith   *string                `json:"name_not_ends_with,omitempty"`
	Desc              *string                `json:"desc,omitempty"`
	DescNot           *string                `json:"desc_not,omitempty"`
	DescIn            []string               `json:"desc_in,omitempty"`
	DescNotIn         []string               `json:"desc_not_in,omitempty"`
	DescLt            *string                `json:"desc_lt,omitempty"`
	DescLte           *string                `json:"desc_lte,omitempty"`
	DescGt            *string                `json:"desc_gt,omitempty"`
	DescGte           *string                `json:"desc_gte,omitempty"`
	DescContains      *string                `json:"desc_contains,omitempty"`
	DescNotContains   *string                `json:"desc_not_contains,omitempty"`
	DescStartsWith    *string                `json:"desc_starts_with,omitempty"`
	DescNotStartsWith *string                `json:"desc_not_starts_with,omitempty"`
	DescEndsWith      *string                `json:"desc_ends_with,omitempty"`
	DescNotEndsWith   *string                `json:"desc_not_ends_with,omitempty"`
	Url               *string                `json:"url,omitempty"`
	UrlNot            *string                `json:"url_not,omitempty"`
	UrlIn             []string               `json:"url_in,omitempty"`
	UrlNotIn          []string               `json:"url_not_in,omitempty"`
	UrlLt             *string                `json:"url_lt,omitempty"`
	UrlLte            *string                `json:"url_lte,omitempty"`
	UrlGt             *string                `json:"url_gt,omitempty"`
	UrlGte            *string                `json:"url_gte,omitempty"`
	UrlContains       *string                `json:"url_contains,omitempty"`
	UrlNotContains    *string                `json:"url_not_contains,omitempty"`
	UrlStartsWith     *string                `json:"url_starts_with,omitempty"`
	UrlNotStartsWith  *string                `json:"url_not_starts_with,omitempty"`
	UrlEndsWith       *string                `json:"url_ends_with,omitempty"`
	UrlNotEndsWith    *string                `json:"url_not_ends_with,omitempty"`
	And               []LinkScalarWhereInput `json:"AND,omitempty"`
	Or                []LinkScalarWhereInput `json:"OR,omitempty"`
	Not               []LinkScalarWhereInput `json:"NOT,omitempty"`
}

type UserUpdateManyMutationInput struct {
	Email     *string `json:"email,omitempty"`
	Firstname *string `json:"firstname,omitempty"`
	Lastname  *string `json:"lastname,omitempty"`
}

type LinkUpdateManyWithWhereNestedInput struct {
	Where LinkScalarWhereInput    `json:"where"`
	Data  LinkUpdateManyDataInput `json:"data"`
}

type ThumbnailUpdateManyMutationInput struct {
	Name *string `json:"name,omitempty"`
	Path *string `json:"path,omitempty"`
}

type LinkUpdateManyDataInput struct {
	Name *string `json:"name,omitempty"`
	Desc *string `json:"desc,omitempty"`
	Url  *string `json:"url,omitempty"`
}

type ThumbnailUpdateInput struct {
	Name *string `json:"name,omitempty"`
	Path *string `json:"path,omitempty"`
}

type NoteUpdateManyWithoutFolioInput struct {
	Create     []NoteCreateWithoutFolioInput                `json:"create,omitempty"`
	Delete     []NoteWhereUniqueInput                       `json:"delete,omitempty"`
	Connect    []NoteWhereUniqueInput                       `json:"connect,omitempty"`
	Set        []NoteWhereUniqueInput                       `json:"set,omitempty"`
	Disconnect []NoteWhereUniqueInput                       `json:"disconnect,omitempty"`
	Update     []NoteUpdateWithWhereUniqueWithoutFolioInput `json:"update,omitempty"`
	Upsert     []NoteUpsertWithWhereUniqueWithoutFolioInput `json:"upsert,omitempty"`
	DeleteMany []NoteScalarWhereInput                       `json:"deleteMany,omitempty"`
	UpdateMany []NoteUpdateManyWithWhereNestedInput         `json:"updateMany,omitempty"`
}

type FolioUpsertWithWhereUniqueWithoutTagsInput struct {
	Where  FolioWhereUniqueInput           `json:"where"`
	Update FolioUpdateWithoutTagsDataInput `json:"update"`
	Create FolioCreateWithoutTagsInput     `json:"create"`
}

type NoteUpdateWithWhereUniqueWithoutFolioInput struct {
	Where NoteWhereUniqueInput            `json:"where"`
	Data  NoteUpdateWithoutFolioDataInput `json:"data"`
}

type FolioUpdateWithoutTagsDataInput struct {
	Name      *string                            `json:"name,omitempty"`
	Desc      *string                            `json:"desc,omitempty"`
	Thumbnail *ThumbnailUpdateOneInput           `json:"thumbnail,omitempty"`
	Assets    *AssetUpdateManyWithoutFolioInput  `json:"assets,omitempty"`
	Links     *LinkUpdateManyWithoutFolioInput   `json:"links,omitempty"`
	Notes     *NoteUpdateManyWithoutFolioInput   `json:"notes,omitempty"`
	Owner     *UserUpdateOneRequiredInput        `json:"owner,omitempty"`
	Shares    *ShareUpdateManyWithoutFoliosInput `json:"shares,omitempty"`
}

type NoteUpdateWithoutFolioDataInput struct {
	Name      *string                  `json:"name,omitempty"`
	Note      *string                  `json:"note,omitempty"`
	Thumbnail *ThumbnailUpdateOneInput `json:"thumbnail,omitempty"`
}

type FolioUpdateManyWithoutTagsInput struct {
	Create     []FolioCreateWithoutTagsInput                `json:"create,omitempty"`
	Delete     []FolioWhereUniqueInput                      `json:"delete,omitempty"`
	Connect    []FolioWhereUniqueInput                      `json:"connect,omitempty"`
	Set        []FolioWhereUniqueInput                      `json:"set,omitempty"`
	Disconnect []FolioWhereUniqueInput                      `json:"disconnect,omitempty"`
	Update     []FolioUpdateWithWhereUniqueWithoutTagsInput `json:"update,omitempty"`
	Upsert     []FolioUpsertWithWhereUniqueWithoutTagsInput `json:"upsert,omitempty"`
	DeleteMany []FolioScalarWhereInput                      `json:"deleteMany,omitempty"`
	UpdateMany []FolioUpdateManyWithWhereNestedInput        `json:"updateMany,omitempty"`
}

type NoteUpsertWithWhereUniqueWithoutFolioInput struct {
	Where  NoteWhereUniqueInput            `json:"where"`
	Update NoteUpdateWithoutFolioDataInput `json:"update"`
	Create NoteCreateWithoutFolioInput     `json:"create"`
}

type TagUpdateInput struct {
	Kind      *TagType                         `json:"kind,omitempty"`
	Name      *string                          `json:"name,omitempty"`
	Desc      *string                          `json:"desc,omitempty"`
	Thumbnail *ThumbnailUpdateOneInput         `json:"thumbnail,omitempty"`
	Folios    *FolioUpdateManyWithoutTagsInput `json:"folios,omitempty"`
}

type NoteScalarWhereInput struct {
	ID                *string                `json:"id,omitempty"`
	IDNot             *string                `json:"id_not,omitempty"`
	IDIn              []string               `json:"id_in,omitempty"`
	IDNotIn           []string               `json:"id_not_in,omitempty"`
	IDLt              *string                `json:"id_lt,omitempty"`
	IDLte             *string                `json:"id_lte,omitempty"`
	IDGt              *string                `json:"id_gt,omitempty"`
	IDGte             *string                `json:"id_gte,omitempty"`
	IDContains        *string                `json:"id_contains,omitempty"`
	IDNotContains     *string                `json:"id_not_contains,omitempty"`
	IDStartsWith      *string                `json:"id_starts_with,omitempty"`
	IDNotStartsWith   *string                `json:"id_not_starts_with,omitempty"`
	IDEndsWith        *string                `json:"id_ends_with,omitempty"`
	IDNotEndsWith     *string                `json:"id_not_ends_with,omitempty"`
	Name              *string                `json:"name,omitempty"`
	NameNot           *string                `json:"name_not,omitempty"`
	NameIn            []string               `json:"name_in,omitempty"`
	NameNotIn         []string               `json:"name_not_in,omitempty"`
	NameLt            *string                `json:"name_lt,omitempty"`
	NameLte           *string                `json:"name_lte,omitempty"`
	NameGt            *string                `json:"name_gt,omitempty"`
	NameGte           *string                `json:"name_gte,omitempty"`
	NameContains      *string                `json:"name_contains,omitempty"`
	NameNotContains   *string                `json:"name_not_contains,omitempty"`
	NameStartsWith    *string                `json:"name_starts_with,omitempty"`
	NameNotStartsWith *string                `json:"name_not_starts_with,omitempty"`
	NameEndsWith      *string                `json:"name_ends_with,omitempty"`
	NameNotEndsWith   *string                `json:"name_not_ends_with,omitempty"`
	Note              *string                `json:"note,omitempty"`
	NoteNot           *string                `json:"note_not,omitempty"`
	NoteIn            []string               `json:"note_in,omitempty"`
	NoteNotIn         []string               `json:"note_not_in,omitempty"`
	NoteLt            *string                `json:"note_lt,omitempty"`
	NoteLte           *string                `json:"note_lte,omitempty"`
	NoteGt            *string                `json:"note_gt,omitempty"`
	NoteGte           *string                `json:"note_gte,omitempty"`
	NoteContains      *string                `json:"note_contains,omitempty"`
	NoteNotContains   *string                `json:"note_not_contains,omitempty"`
	NoteStartsWith    *string                `json:"note_starts_with,omitempty"`
	NoteNotStartsWith *string                `json:"note_not_starts_with,omitempty"`
	NoteEndsWith      *string                `json:"note_ends_with,omitempty"`
	NoteNotEndsWith   *string                `json:"note_not_ends_with,omitempty"`
	And               []NoteScalarWhereInput `json:"AND,omitempty"`
	Or                []NoteScalarWhereInput `json:"OR,omitempty"`
	Not               []NoteScalarWhereInput `json:"NOT,omitempty"`
}

type FolioCreateManyWithoutTagsInput struct {
	Create  []FolioCreateWithoutTagsInput `json:"create,omitempty"`
	Connect []FolioWhereUniqueInput       `json:"connect,omitempty"`
}

type NoteUpdateManyWithWhereNestedInput struct {
	Where NoteScalarWhereInput    `json:"where"`
	Data  NoteUpdateManyDataInput `json:"data"`
}

type TagCreateInput struct {
	Kind      *TagType                         `json:"kind,omitempty"`
	Name      string                           `json:"name"`
	Desc      string                           `json:"desc"`
	Thumbnail *ThumbnailCreateOneInput         `json:"thumbnail,omitempty"`
	Folios    *FolioCreateManyWithoutTagsInput `json:"folios,omitempty"`
}

type NoteUpdateManyDataInput struct {
	Name *string `json:"name,omitempty"`
	Note *string `json:"note,omitempty"`
}

type FolioUpdateManyWithWhereNestedInput struct {
	Where FolioScalarWhereInput    `json:"where"`
	Data  FolioUpdateManyDataInput `json:"data"`
}

type UserUpdateOneRequiredInput struct {
	Create  *UserCreateInput       `json:"create,omitempty"`
	Update  *UserUpdateDataInput   `json:"update,omitempty"`
	Upsert  *UserUpsertNestedInput `json:"upsert,omitempty"`
	Connect *UserWhereUniqueInput  `json:"connect,omitempty"`
}

type FolioScalarWhereInput struct {
	ID                *string                 `json:"id,omitempty"`
	IDNot             *string                 `json:"id_not,omitempty"`
	IDIn              []string                `json:"id_in,omitempty"`
	IDNotIn           []string                `json:"id_not_in,omitempty"`
	IDLt              *string                 `json:"id_lt,omitempty"`
	IDLte             *string                 `json:"id_lte,omitempty"`
	IDGt              *string                 `json:"id_gt,omitempty"`
	IDGte             *string                 `json:"id_gte,omitempty"`
	IDContains        *string                 `json:"id_contains,omitempty"`
	IDNotContains     *string                 `json:"id_not_contains,omitempty"`
	IDStartsWith      *string                 `json:"id_starts_with,omitempty"`
	IDNotStartsWith   *string                 `json:"id_not_starts_with,omitempty"`
	IDEndsWith        *string                 `json:"id_ends_with,omitempty"`
	IDNotEndsWith     *string                 `json:"id_not_ends_with,omitempty"`
	Name              *string                 `json:"name,omitempty"`
	NameNot           *string                 `json:"name_not,omitempty"`
	NameIn            []string                `json:"name_in,omitempty"`
	NameNotIn         []string                `json:"name_not_in,omitempty"`
	NameLt            *string                 `json:"name_lt,omitempty"`
	NameLte           *string                 `json:"name_lte,omitempty"`
	NameGt            *string                 `json:"name_gt,omitempty"`
	NameGte           *string                 `json:"name_gte,omitempty"`
	NameContains      *string                 `json:"name_contains,omitempty"`
	NameNotContains   *string                 `json:"name_not_contains,omitempty"`
	NameStartsWith    *string                 `json:"name_starts_with,omitempty"`
	NameNotStartsWith *string                 `json:"name_not_starts_with,omitempty"`
	NameEndsWith      *string                 `json:"name_ends_with,omitempty"`
	NameNotEndsWith   *string                 `json:"name_not_ends_with,omitempty"`
	Desc              *string                 `json:"desc,omitempty"`
	DescNot           *string                 `json:"desc_not,omitempty"`
	DescIn            []string                `json:"desc_in,omitempty"`
	DescNotIn         []string                `json:"desc_not_in,omitempty"`
	DescLt            *string                 `json:"desc_lt,omitempty"`
	DescLte           *string                 `json:"desc_lte,omitempty"`
	DescGt            *string                 `json:"desc_gt,omitempty"`
	DescGte           *string                 `json:"desc_gte,omitempty"`
	DescContains      *string                 `json:"desc_contains,omitempty"`
	DescNotContains   *string                 `json:"desc_not_contains,omitempty"`
	DescStartsWith    *string                 `json:"desc_starts_with,omitempty"`
	DescNotStartsWith *string                 `json:"desc_not_starts_with,omitempty"`
	DescEndsWith      *string                 `json:"desc_ends_with,omitempty"`
	DescNotEndsWith   *string                 `json:"desc_not_ends_with,omitempty"`
	And               []FolioScalarWhereInput `json:"AND,omitempty"`
	Or                []FolioScalarWhereInput `json:"OR,omitempty"`
	Not               []FolioScalarWhereInput `json:"NOT,omitempty"`
}

type UserUpdateDataInput struct {
	Email     *string                           `json:"email,omitempty"`
	Firstname *string                           `json:"firstname,omitempty"`
	Lastname  *string                           `json:"lastname,omitempty"`
	Thumbnail *ThumbnailUpdateOneInput          `json:"thumbnail,omitempty"`
	Posts     *PostUpdateManyWithoutAuthorInput `json:"posts,omitempty"`
}

type FolioUpdateWithoutSharesDataInput struct {
	Name      *string                           `json:"name,omitempty"`
	Desc      *string                           `json:"desc,omitempty"`
	Thumbnail *ThumbnailUpdateOneInput          `json:"thumbnail,omitempty"`
	Assets    *AssetUpdateManyWithoutFolioInput `json:"assets,omitempty"`
	Links     *LinkUpdateManyWithoutFolioInput  `json:"links,omitempty"`
	Notes     *NoteUpdateManyWithoutFolioInput  `json:"notes,omitempty"`
	Owner     *UserUpdateOneRequiredInput       `json:"owner,omitempty"`
	Tags      *TagUpdateManyWithoutFoliosInput  `json:"tags,omitempty"`
}

type PostUpdateManyWithoutAuthorInput struct {
	Create     []PostCreateWithoutAuthorInput                `json:"create,omitempty"`
	Delete     []PostWhereUniqueInput                        `json:"delete,omitempty"`
	Connect    []PostWhereUniqueInput                        `json:"connect,omitempty"`
	Set        []PostWhereUniqueInput                        `json:"set,omitempty"`
	Disconnect []PostWhereUniqueInput                        `json:"disconnect,omitempty"`
	Update     []PostUpdateWithWhereUniqueWithoutAuthorInput `json:"update,omitempty"`
	Upsert     []PostUpsertWithWhereUniqueWithoutAuthorInput `json:"upsert,omitempty"`
	DeleteMany []PostScalarWhereInput                        `json:"deleteMany,omitempty"`
	UpdateMany []PostUpdateManyWithWhereNestedInput          `json:"updateMany,omitempty"`
}

type FolioUpdateWithWhereUniqueWithoutSharesInput struct {
	Where FolioWhereUniqueInput             `json:"where"`
	Data  FolioUpdateWithoutSharesDataInput `json:"data"`
}

type UserCreateWithoutPostsInput struct {
	Email     *string                  `json:"email,omitempty"`
	Firstname string                   `json:"firstname"`
	Lastname  string                   `json:"lastname"`
	Thumbnail *ThumbnailCreateOneInput `json:"thumbnail,omitempty"`
}

type ShareUpdateInput struct {
	Owner     *UserUpdateOneRequiredInput        `json:"owner,omitempty"`
	Friend    *UserUpdateOneRequiredInput        `json:"friend,omitempty"`
	Thumbnail *ThumbnailUpdateOneInput           `json:"thumbnail,omitempty"`
	Folios    *FolioUpdateManyWithoutSharesInput `json:"folios,omitempty"`
}

type PostUpdateWithoutAuthorDataInput struct {
	Title     *string `json:"title,omitempty"`
	Published *bool   `json:"published,omitempty"`
}

type FolioCreateWithoutSharesInput struct {
	Name      string                            `json:"name"`
	Desc      string                            `json:"desc"`
	Thumbnail *ThumbnailCreateOneInput          `json:"thumbnail,omitempty"`
	Assets    *AssetCreateManyWithoutFolioInput `json:"assets,omitempty"`
	Links     *LinkCreateManyWithoutFolioInput  `json:"links,omitempty"`
	Notes     *NoteCreateManyWithoutFolioInput  `json:"notes,omitempty"`
	Owner     UserCreateOneInput                `json:"owner"`
	Tags      *TagCreateManyWithoutFoliosInput  `json:"tags,omitempty"`
}

type PostUpsertWithWhereUniqueWithoutAuthorInput struct {
	Where  PostWhereUniqueInput             `json:"where"`
	Update PostUpdateWithoutAuthorDataInput `json:"update"`
	Create PostCreateWithoutAuthorInput     `json:"create"`
}

type ShareCreateInput struct {
	Owner     UserCreateOneInput                 `json:"owner"`
	Friend    UserCreateOneInput                 `json:"friend"`
	Thumbnail *ThumbnailCreateOneInput           `json:"thumbnail,omitempty"`
	Folios    *FolioCreateManyWithoutSharesInput `json:"folios,omitempty"`
}

type PostScalarWhereInput struct {
	ID                 *string                `json:"id,omitempty"`
	IDNot              *string                `json:"id_not,omitempty"`
	IDIn               []string               `json:"id_in,omitempty"`
	IDNotIn            []string               `json:"id_not_in,omitempty"`
	IDLt               *string                `json:"id_lt,omitempty"`
	IDLte              *string                `json:"id_lte,omitempty"`
	IDGt               *string                `json:"id_gt,omitempty"`
	IDGte              *string                `json:"id_gte,omitempty"`
	IDContains         *string                `json:"id_contains,omitempty"`
	IDNotContains      *string                `json:"id_not_contains,omitempty"`
	IDStartsWith       *string                `json:"id_starts_with,omitempty"`
	IDNotStartsWith    *string                `json:"id_not_starts_with,omitempty"`
	IDEndsWith         *string                `json:"id_ends_with,omitempty"`
	IDNotEndsWith      *string                `json:"id_not_ends_with,omitempty"`
	Title              *string                `json:"title,omitempty"`
	TitleNot           *string                `json:"title_not,omitempty"`
	TitleIn            []string               `json:"title_in,omitempty"`
	TitleNotIn         []string               `json:"title_not_in,omitempty"`
	TitleLt            *string                `json:"title_lt,omitempty"`
	TitleLte           *string                `json:"title_lte,omitempty"`
	TitleGt            *string                `json:"title_gt,omitempty"`
	TitleGte           *string                `json:"title_gte,omitempty"`
	TitleContains      *string                `json:"title_contains,omitempty"`
	TitleNotContains   *string                `json:"title_not_contains,omitempty"`
	TitleStartsWith    *string                `json:"title_starts_with,omitempty"`
	TitleNotStartsWith *string                `json:"title_not_starts_with,omitempty"`
	TitleEndsWith      *string                `json:"title_ends_with,omitempty"`
	TitleNotEndsWith   *string                `json:"title_not_ends_with,omitempty"`
	Published          *bool                  `json:"published,omitempty"`
	PublishedNot       *bool                  `json:"published_not,omitempty"`
	And                []PostScalarWhereInput `json:"AND,omitempty"`
	Or                 []PostScalarWhereInput `json:"OR,omitempty"`
	Not                []PostScalarWhereInput `json:"NOT,omitempty"`
}

type UserWhereUniqueInput struct {
	ID    *string `json:"id,omitempty"`
	Email *string `json:"email,omitempty"`
}

type PostUpdateManyWithWhereNestedInput struct {
	Where PostScalarWhereInput    `json:"where"`
	Data  PostUpdateManyDataInput `json:"data"`
}

type UserUpdateWithoutPostsDataInput struct {
	Email     *string                  `json:"email,omitempty"`
	Firstname *string                  `json:"firstname,omitempty"`
	Lastname  *string                  `json:"lastname,omitempty"`
	Thumbnail *ThumbnailUpdateOneInput `json:"thumbnail,omitempty"`
}

type PostUpdateManyDataInput struct {
	Title     *string `json:"title,omitempty"`
	Published *bool   `json:"published,omitempty"`
}

type PostUpdateInput struct {
	Title     *string                         `json:"title,omitempty"`
	Published *bool                           `json:"published,omitempty"`
	Author    *UserUpdateOneWithoutPostsInput `json:"author,omitempty"`
}

type UserUpsertNestedInput struct {
	Update UserUpdateDataInput `json:"update"`
	Create UserCreateInput     `json:"create"`
}

type AssetCreateInput struct {
	Name      string                            `json:"name"`
	Uuid      *string                           `json:"uuid,omitempty"`
	Path      *string                           `json:"path,omitempty"`
	Note      *string                           `json:"note,omitempty"`
	MimeType  *string                           `json:"mimeType,omitempty"`
	Thumbnail *ThumbnailCreateOneInput          `json:"thumbnail,omitempty"`
	Folio     *FolioCreateOneWithoutAssetsInput `json:"folio,omitempty"`
}

type TagWhereInput struct {
	ID                *string              `json:"id,omitempty"`
	IDNot             *string              `json:"id_not,omitempty"`
	IDIn              []string             `json:"id_in,omitempty"`
	IDNotIn           []string             `json:"id_not_in,omitempty"`
	IDLt              *string              `json:"id_lt,omitempty"`
	IDLte             *string              `json:"id_lte,omitempty"`
	IDGt              *string              `json:"id_gt,omitempty"`
	IDGte             *string              `json:"id_gte,omitempty"`
	IDContains        *string              `json:"id_contains,omitempty"`
	IDNotContains     *string              `json:"id_not_contains,omitempty"`
	IDStartsWith      *string              `json:"id_starts_with,omitempty"`
	IDNotStartsWith   *string              `json:"id_not_starts_with,omitempty"`
	IDEndsWith        *string              `json:"id_ends_with,omitempty"`
	IDNotEndsWith     *string              `json:"id_not_ends_with,omitempty"`
	Kind              *TagType             `json:"kind,omitempty"`
	KindNot           *TagType             `json:"kind_not,omitempty"`
	KindIn            []TagType            `json:"kind_in,omitempty"`
	KindNotIn         []TagType            `json:"kind_not_in,omitempty"`
	Name              *string              `json:"name,omitempty"`
	NameNot           *string              `json:"name_not,omitempty"`
	NameIn            []string             `json:"name_in,omitempty"`
	NameNotIn         []string             `json:"name_not_in,omitempty"`
	NameLt            *string              `json:"name_lt,omitempty"`
	NameLte           *string              `json:"name_lte,omitempty"`
	NameGt            *string              `json:"name_gt,omitempty"`
	NameGte           *string              `json:"name_gte,omitempty"`
	NameContains      *string              `json:"name_contains,omitempty"`
	NameNotContains   *string              `json:"name_not_contains,omitempty"`
	NameStartsWith    *string              `json:"name_starts_with,omitempty"`
	NameNotStartsWith *string              `json:"name_not_starts_with,omitempty"`
	NameEndsWith      *string              `json:"name_ends_with,omitempty"`
	NameNotEndsWith   *string              `json:"name_not_ends_with,omitempty"`
	Desc              *string              `json:"desc,omitempty"`
	DescNot           *string              `json:"desc_not,omitempty"`
	DescIn            []string             `json:"desc_in,omitempty"`
	DescNotIn         []string             `json:"desc_not_in,omitempty"`
	DescLt            *string              `json:"desc_lt,omitempty"`
	DescLte           *string              `json:"desc_lte,omitempty"`
	DescGt            *string              `json:"desc_gt,omitempty"`
	DescGte           *string              `json:"desc_gte,omitempty"`
	DescContains      *string              `json:"desc_contains,omitempty"`
	DescNotContains   *string              `json:"desc_not_contains,omitempty"`
	DescStartsWith    *string              `json:"desc_starts_with,omitempty"`
	DescNotStartsWith *string              `json:"desc_not_starts_with,omitempty"`
	DescEndsWith      *string              `json:"desc_ends_with,omitempty"`
	DescNotEndsWith   *string              `json:"desc_not_ends_with,omitempty"`
	Thumbnail         *ThumbnailWhereInput `json:"thumbnail,omitempty"`
	FoliosEvery       *FolioWhereInput     `json:"folios_every,omitempty"`
	FoliosSome        *FolioWhereInput     `json:"folios_some,omitempty"`
	FoliosNone        *FolioWhereInput     `json:"folios_none,omitempty"`
	And               []TagWhereInput      `json:"AND,omitempty"`
	Or                []TagWhereInput      `json:"OR,omitempty"`
	Not               []TagWhereInput      `json:"NOT,omitempty"`
}

type ThumbnailCreateInput struct {
	Name string  `json:"name"`
	Path *string `json:"path,omitempty"`
}

type TagUpdateWithWhereUniqueWithoutFoliosInput struct {
	Where TagWhereUniqueInput             `json:"where"`
	Data  TagUpdateWithoutFoliosDataInput `json:"data"`
}

type FolioCreateWithoutAssetsInput struct {
	Name      string                             `json:"name"`
	Desc      string                             `json:"desc"`
	Thumbnail *ThumbnailCreateOneInput           `json:"thumbnail,omitempty"`
	Links     *LinkCreateManyWithoutFolioInput   `json:"links,omitempty"`
	Notes     *NoteCreateManyWithoutFolioInput   `json:"notes,omitempty"`
	Owner     UserCreateOneInput                 `json:"owner"`
	Tags      *TagCreateManyWithoutFoliosInput   `json:"tags,omitempty"`
	Shares    *ShareCreateManyWithoutFoliosInput `json:"shares,omitempty"`
}

type TagUpdateWithoutFoliosDataInput struct {
	Kind      *TagType                 `json:"kind,omitempty"`
	Name      *string                  `json:"name,omitempty"`
	Desc      *string                  `json:"desc,omitempty"`
	Thumbnail *ThumbnailUpdateOneInput `json:"thumbnail,omitempty"`
}

type LinkCreateWithoutFolioInput struct {
	Name      string                   `json:"name"`
	Desc      *string                  `json:"desc,omitempty"`
	Url       *string                  `json:"url,omitempty"`
	Thumbnail *ThumbnailCreateOneInput `json:"thumbnail,omitempty"`
}

type TagUpsertWithWhereUniqueWithoutFoliosInput struct {
	Where  TagWhereUniqueInput             `json:"where"`
	Update TagUpdateWithoutFoliosDataInput `json:"update"`
	Create TagCreateWithoutFoliosInput     `json:"create"`
}

type NoteCreateWithoutFolioInput struct {
	Name      string                   `json:"name"`
	Note      *string                  `json:"note,omitempty"`
	Thumbnail *ThumbnailCreateOneInput `json:"thumbnail,omitempty"`
}

type TagScalarWhereInput struct {
	ID                *string               `json:"id,omitempty"`
	IDNot             *string               `json:"id_not,omitempty"`
	IDIn              []string              `json:"id_in,omitempty"`
	IDNotIn           []string              `json:"id_not_in,omitempty"`
	IDLt              *string               `json:"id_lt,omitempty"`
	IDLte             *string               `json:"id_lte,omitempty"`
	IDGt              *string               `json:"id_gt,omitempty"`
	IDGte             *string               `json:"id_gte,omitempty"`
	IDContains        *string               `json:"id_contains,omitempty"`
	IDNotContains     *string               `json:"id_not_contains,omitempty"`
	IDStartsWith      *string               `json:"id_starts_with,omitempty"`
	IDNotStartsWith   *string               `json:"id_not_starts_with,omitempty"`
	IDEndsWith        *string               `json:"id_ends_with,omitempty"`
	IDNotEndsWith     *string               `json:"id_not_ends_with,omitempty"`
	Kind              *TagType              `json:"kind,omitempty"`
	KindNot           *TagType              `json:"kind_not,omitempty"`
	KindIn            []TagType             `json:"kind_in,omitempty"`
	KindNotIn         []TagType             `json:"kind_not_in,omitempty"`
	Name              *string               `json:"name,omitempty"`
	NameNot           *string               `json:"name_not,omitempty"`
	NameIn            []string              `json:"name_in,omitempty"`
	NameNotIn         []string              `json:"name_not_in,omitempty"`
	NameLt            *string               `json:"name_lt,omitempty"`
	NameLte           *string               `json:"name_lte,omitempty"`
	NameGt            *string               `json:"name_gt,omitempty"`
	NameGte           *string               `json:"name_gte,omitempty"`
	NameContains      *string               `json:"name_contains,omitempty"`
	NameNotContains   *string               `json:"name_not_contains,omitempty"`
	NameStartsWith    *string               `json:"name_starts_with,omitempty"`
	NameNotStartsWith *string               `json:"name_not_starts_with,omitempty"`
	NameEndsWith      *string               `json:"name_ends_with,omitempty"`
	NameNotEndsWith   *string               `json:"name_not_ends_with,omitempty"`
	Desc              *string               `json:"desc,omitempty"`
	DescNot           *string               `json:"desc_not,omitempty"`
	DescIn            []string              `json:"desc_in,omitempty"`
	DescNotIn         []string              `json:"desc_not_in,omitempty"`
	DescLt            *string               `json:"desc_lt,omitempty"`
	DescLte           *string               `json:"desc_lte,omitempty"`
	DescGt            *string               `json:"desc_gt,omitempty"`
	DescGte           *string               `json:"desc_gte,omitempty"`
	DescContains      *string               `json:"desc_contains,omitempty"`
	DescNotContains   *string               `json:"desc_not_contains,omitempty"`
	DescStartsWith    *string               `json:"desc_starts_with,omitempty"`
	DescNotStartsWith *string               `json:"desc_not_starts_with,omitempty"`
	DescEndsWith      *string               `json:"desc_ends_with,omitempty"`
	DescNotEndsWith   *string               `json:"desc_not_ends_with,omitempty"`
	And               []TagScalarWhereInput `json:"AND,omitempty"`
	Or                []TagScalarWhereInput `json:"OR,omitempty"`
	Not               []TagScalarWhereInput `json:"NOT,omitempty"`
}

type UserCreateInput struct {
	Email     *string                           `json:"email,omitempty"`
	Firstname string                            `json:"firstname"`
	Lastname  string                            `json:"lastname"`
	Thumbnail *ThumbnailCreateOneInput          `json:"thumbnail,omitempty"`
	Posts     *PostCreateManyWithoutAuthorInput `json:"posts,omitempty"`
}

type TagUpdateManyWithWhereNestedInput struct {
	Where TagScalarWhereInput    `json:"where"`
	Data  TagUpdateManyDataInput `json:"data"`
}

type PostCreateWithoutAuthorInput struct {
	Title     string `json:"title"`
	Published *bool  `json:"published,omitempty"`
}

type TagUpdateManyDataInput struct {
	Kind *TagType `json:"kind,omitempty"`
	Name *string  `json:"name,omitempty"`
	Desc *string  `json:"desc,omitempty"`
}

type TagCreateWithoutFoliosInput struct {
	Kind      *TagType                 `json:"kind,omitempty"`
	Name      string                   `json:"name"`
	Desc      string                   `json:"desc"`
	Thumbnail *ThumbnailCreateOneInput `json:"thumbnail,omitempty"`
}

type ShareUpdateManyWithoutFoliosInput struct {
	Create     []ShareCreateWithoutFoliosInput                `json:"create,omitempty"`
	Delete     []ShareWhereUniqueInput                        `json:"delete,omitempty"`
	Connect    []ShareWhereUniqueInput                        `json:"connect,omitempty"`
	Set        []ShareWhereUniqueInput                        `json:"set,omitempty"`
	Disconnect []ShareWhereUniqueInput                        `json:"disconnect,omitempty"`
	Update     []ShareUpdateWithWhereUniqueWithoutFoliosInput `json:"update,omitempty"`
	Upsert     []ShareUpsertWithWhereUniqueWithoutFoliosInput `json:"upsert,omitempty"`
	DeleteMany []ShareScalarWhereInput                        `json:"deleteMany,omitempty"`
}

type ShareCreateWithoutFoliosInput struct {
	Owner     UserCreateOneInput       `json:"owner"`
	Friend    UserCreateOneInput       `json:"friend"`
	Thumbnail *ThumbnailCreateOneInput `json:"thumbnail,omitempty"`
}

type ShareUpdateWithWhereUniqueWithoutFoliosInput struct {
	Where ShareWhereUniqueInput             `json:"where"`
	Data  ShareUpdateWithoutFoliosDataInput `json:"data"`
}

type UserWhereInput struct {
	ID                     *string              `json:"id,omitempty"`
	IDNot                  *string              `json:"id_not,omitempty"`
	IDIn                   []string             `json:"id_in,omitempty"`
	IDNotIn                []string             `json:"id_not_in,omitempty"`
	IDLt                   *string              `json:"id_lt,omitempty"`
	IDLte                  *string              `json:"id_lte,omitempty"`
	IDGt                   *string              `json:"id_gt,omitempty"`
	IDGte                  *string              `json:"id_gte,omitempty"`
	IDContains             *string              `json:"id_contains,omitempty"`
	IDNotContains          *string              `json:"id_not_contains,omitempty"`
	IDStartsWith           *string              `json:"id_starts_with,omitempty"`
	IDNotStartsWith        *string              `json:"id_not_starts_with,omitempty"`
	IDEndsWith             *string              `json:"id_ends_with,omitempty"`
	IDNotEndsWith          *string              `json:"id_not_ends_with,omitempty"`
	Email                  *string              `json:"email,omitempty"`
	EmailNot               *string              `json:"email_not,omitempty"`
	EmailIn                []string             `json:"email_in,omitempty"`
	EmailNotIn             []string             `json:"email_not_in,omitempty"`
	EmailLt                *string              `json:"email_lt,omitempty"`
	EmailLte               *string              `json:"email_lte,omitempty"`
	EmailGt                *string              `json:"email_gt,omitempty"`
	EmailGte               *string              `json:"email_gte,omitempty"`
	EmailContains          *string              `json:"email_contains,omitempty"`
	EmailNotContains       *string              `json:"email_not_contains,omitempty"`
	EmailStartsWith        *string              `json:"email_starts_with,omitempty"`
	EmailNotStartsWith     *string              `json:"email_not_starts_with,omitempty"`
	EmailEndsWith          *string              `json:"email_ends_with,omitempty"`
	EmailNotEndsWith       *string              `json:"email_not_ends_with,omitempty"`
	Firstname              *string              `json:"firstname,omitempty"`
	FirstnameNot           *string              `json:"firstname_not,omitempty"`
	FirstnameIn            []string             `json:"firstname_in,omitempty"`
	FirstnameNotIn         []string             `json:"firstname_not_in,omitempty"`
	FirstnameLt            *string              `json:"firstname_lt,omitempty"`
	FirstnameLte           *string              `json:"firstname_lte,omitempty"`
	FirstnameGt            *string              `json:"firstname_gt,omitempty"`
	FirstnameGte           *string              `json:"firstname_gte,omitempty"`
	FirstnameContains      *string              `json:"firstname_contains,omitempty"`
	FirstnameNotContains   *string              `json:"firstname_not_contains,omitempty"`
	FirstnameStartsWith    *string              `json:"firstname_starts_with,omitempty"`
	FirstnameNotStartsWith *string              `json:"firstname_not_starts_with,omitempty"`
	FirstnameEndsWith      *string              `json:"firstname_ends_with,omitempty"`
	FirstnameNotEndsWith   *string              `json:"firstname_not_ends_with,omitempty"`
	Lastname               *string              `json:"lastname,omitempty"`
	LastnameNot            *string              `json:"lastname_not,omitempty"`
	LastnameIn             []string             `json:"lastname_in,omitempty"`
	LastnameNotIn          []string             `json:"lastname_not_in,omitempty"`
	LastnameLt             *string              `json:"lastname_lt,omitempty"`
	LastnameLte            *string              `json:"lastname_lte,omitempty"`
	LastnameGt             *string              `json:"lastname_gt,omitempty"`
	LastnameGte            *string              `json:"lastname_gte,omitempty"`
	LastnameContains       *string              `json:"lastname_contains,omitempty"`
	LastnameNotContains    *string              `json:"lastname_not_contains,omitempty"`
	LastnameStartsWith     *string              `json:"lastname_starts_with,omitempty"`
	LastnameNotStartsWith  *string              `json:"lastname_not_starts_with,omitempty"`
	LastnameEndsWith       *string              `json:"lastname_ends_with,omitempty"`
	LastnameNotEndsWith    *string              `json:"lastname_not_ends_with,omitempty"`
	Thumbnail              *ThumbnailWhereInput `json:"thumbnail,omitempty"`
	PostsEvery             *PostWhereInput      `json:"posts_every,omitempty"`
	PostsSome              *PostWhereInput      `json:"posts_some,omitempty"`
	PostsNone              *PostWhereInput      `json:"posts_none,omitempty"`
	And                    []UserWhereInput     `json:"AND,omitempty"`
	Or                     []UserWhereInput     `json:"OR,omitempty"`
	Not                    []UserWhereInput     `json:"NOT,omitempty"`
}

type ShareUpdateWithoutFoliosDataInput struct {
	Owner     *UserUpdateOneRequiredInput `json:"owner,omitempty"`
	Friend    *UserUpdateOneRequiredInput `json:"friend,omitempty"`
	Thumbnail *ThumbnailUpdateOneInput    `json:"thumbnail,omitempty"`
}

type LinkWhereInput struct {
	ID                *string              `json:"id,omitempty"`
	IDNot             *string              `json:"id_not,omitempty"`
	IDIn              []string             `json:"id_in,omitempty"`
	IDNotIn           []string             `json:"id_not_in,omitempty"`
	IDLt              *string              `json:"id_lt,omitempty"`
	IDLte             *string              `json:"id_lte,omitempty"`
	IDGt              *string              `json:"id_gt,omitempty"`
	IDGte             *string              `json:"id_gte,omitempty"`
	IDContains        *string              `json:"id_contains,omitempty"`
	IDNotContains     *string              `json:"id_not_contains,omitempty"`
	IDStartsWith      *string              `json:"id_starts_with,omitempty"`
	IDNotStartsWith   *string              `json:"id_not_starts_with,omitempty"`
	IDEndsWith        *string              `json:"id_ends_with,omitempty"`
	IDNotEndsWith     *string              `json:"id_not_ends_with,omitempty"`
	Name              *string              `json:"name,omitempty"`
	NameNot           *string              `json:"name_not,omitempty"`
	NameIn            []string             `json:"name_in,omitempty"`
	NameNotIn         []string             `json:"name_not_in,omitempty"`
	NameLt            *string              `json:"name_lt,omitempty"`
	NameLte           *string              `json:"name_lte,omitempty"`
	NameGt            *string              `json:"name_gt,omitempty"`
	NameGte           *string              `json:"name_gte,omitempty"`
	NameContains      *string              `json:"name_contains,omitempty"`
	NameNotContains   *string              `json:"name_not_contains,omitempty"`
	NameStartsWith    *string              `json:"name_starts_with,omitempty"`
	NameNotStartsWith *string              `json:"name_not_starts_with,omitempty"`
	NameEndsWith      *string              `json:"name_ends_with,omitempty"`
	NameNotEndsWith   *string              `json:"name_not_ends_with,omitempty"`
	Desc              *string              `json:"desc,omitempty"`
	DescNot           *string              `json:"desc_not,omitempty"`
	DescIn            []string             `json:"desc_in,omitempty"`
	DescNotIn         []string             `json:"desc_not_in,omitempty"`
	DescLt            *string              `json:"desc_lt,omitempty"`
	DescLte           *string              `json:"desc_lte,omitempty"`
	DescGt            *string              `json:"desc_gt,omitempty"`
	DescGte           *string              `json:"desc_gte,omitempty"`
	DescContains      *string              `json:"desc_contains,omitempty"`
	DescNotContains   *string              `json:"desc_not_contains,omitempty"`
	DescStartsWith    *string              `json:"desc_starts_with,omitempty"`
	DescNotStartsWith *string              `json:"desc_not_starts_with,omitempty"`
	DescEndsWith      *string              `json:"desc_ends_with,omitempty"`
	DescNotEndsWith   *string              `json:"desc_not_ends_with,omitempty"`
	Url               *string              `json:"url,omitempty"`
	UrlNot            *string              `json:"url_not,omitempty"`
	UrlIn             []string             `json:"url_in,omitempty"`
	UrlNotIn          []string             `json:"url_not_in,omitempty"`
	UrlLt             *string              `json:"url_lt,omitempty"`
	UrlLte            *string              `json:"url_lte,omitempty"`
	UrlGt             *string              `json:"url_gt,omitempty"`
	UrlGte            *string              `json:"url_gte,omitempty"`
	UrlContains       *string              `json:"url_contains,omitempty"`
	UrlNotContains    *string              `json:"url_not_contains,omitempty"`
	UrlStartsWith     *string              `json:"url_starts_with,omitempty"`
	UrlNotStartsWith  *string              `json:"url_not_starts_with,omitempty"`
	UrlEndsWith       *string              `json:"url_ends_with,omitempty"`
	UrlNotEndsWith    *string              `json:"url_not_ends_with,omitempty"`
	Thumbnail         *ThumbnailWhereInput `json:"thumbnail,omitempty"`
	Folio             *FolioWhereInput     `json:"folio,omitempty"`
	And               []LinkWhereInput     `json:"AND,omitempty"`
	Or                []LinkWhereInput     `json:"OR,omitempty"`
	Not               []LinkWhereInput     `json:"NOT,omitempty"`
}

type ShareUpsertWithWhereUniqueWithoutFoliosInput struct {
	Where  ShareWhereUniqueInput             `json:"where"`
	Update ShareUpdateWithoutFoliosDataInput `json:"update"`
	Create ShareCreateWithoutFoliosInput     `json:"create"`
}

type PostSubscriptionWhereInput struct {
	MutationIn                 []MutationType               `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                      `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                     `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                     `json:"updatedFields_contains_some,omitempty"`
	Node                       *PostWhereInput              `json:"node,omitempty"`
	And                        []PostSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []PostSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []PostSubscriptionWhereInput `json:"NOT,omitempty"`
}

type ShareScalarWhereInput struct {
	ID              *string                 `json:"id,omitempty"`
	IDNot           *string                 `json:"id_not,omitempty"`
	IDIn            []string                `json:"id_in,omitempty"`
	IDNotIn         []string                `json:"id_not_in,omitempty"`
	IDLt            *string                 `json:"id_lt,omitempty"`
	IDLte           *string                 `json:"id_lte,omitempty"`
	IDGt            *string                 `json:"id_gt,omitempty"`
	IDGte           *string                 `json:"id_gte,omitempty"`
	IDContains      *string                 `json:"id_contains,omitempty"`
	IDNotContains   *string                 `json:"id_not_contains,omitempty"`
	IDStartsWith    *string                 `json:"id_starts_with,omitempty"`
	IDNotStartsWith *string                 `json:"id_not_starts_with,omitempty"`
	IDEndsWith      *string                 `json:"id_ends_with,omitempty"`
	IDNotEndsWith   *string                 `json:"id_not_ends_with,omitempty"`
	And             []ShareScalarWhereInput `json:"AND,omitempty"`
	Or              []ShareScalarWhereInput `json:"OR,omitempty"`
	Not             []ShareScalarWhereInput `json:"NOT,omitempty"`
}

type LinkSubscriptionWhereInput struct {
	MutationIn                 []MutationType               `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                      `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                     `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                     `json:"updatedFields_contains_some,omitempty"`
	Node                       *LinkWhereInput              `json:"node,omitempty"`
	And                        []LinkSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []LinkSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []LinkSubscriptionWhereInput `json:"NOT,omitempty"`
}

type FolioUpsertWithoutAssetsInput struct {
	Update FolioUpdateWithoutAssetsDataInput `json:"update"`
	Create FolioCreateWithoutAssetsInput     `json:"create"`
}

type UserUpdateInput struct {
	Email     *string                           `json:"email,omitempty"`
	Firstname *string                           `json:"firstname,omitempty"`
	Lastname  *string                           `json:"lastname,omitempty"`
	Thumbnail *ThumbnailUpdateOneInput          `json:"thumbnail,omitempty"`
	Posts     *PostUpdateManyWithoutAuthorInput `json:"posts,omitempty"`
}

type AssetUpdateManyMutationInput struct {
	Name     *string `json:"name,omitempty"`
	Uuid     *string `json:"uuid,omitempty"`
	Path     *string `json:"path,omitempty"`
	Note     *string `json:"note,omitempty"`
	MimeType *string `json:"mimeType,omitempty"`
}

type TagUpdateManyMutationInput struct {
	Kind *TagType `json:"kind,omitempty"`
	Name *string  `json:"name,omitempty"`
	Desc *string  `json:"desc,omitempty"`
}

type UserCreateOneWithoutPostsInput struct {
	Create  *UserCreateWithoutPostsInput `json:"create,omitempty"`
	Connect *UserWhereUniqueInput        `json:"connect,omitempty"`
}

type FolioUpdateWithWhereUniqueWithoutTagsInput struct {
	Where FolioWhereUniqueInput           `json:"where"`
	Data  FolioUpdateWithoutTagsDataInput `json:"data"`
}

type PostCreateInput struct {
	Title     string                          `json:"title"`
	Published *bool                           `json:"published,omitempty"`
	Author    *UserCreateOneWithoutPostsInput `json:"author,omitempty"`
}

type FolioCreateWithoutTagsInput struct {
	Name      string                             `json:"name"`
	Desc      string                             `json:"desc"`
	Thumbnail *ThumbnailCreateOneInput           `json:"thumbnail,omitempty"`
	Assets    *AssetCreateManyWithoutFolioInput  `json:"assets,omitempty"`
	Links     *LinkCreateManyWithoutFolioInput   `json:"links,omitempty"`
	Notes     *NoteCreateManyWithoutFolioInput   `json:"notes,omitempty"`
	Owner     UserCreateOneInput                 `json:"owner"`
	Shares    *ShareCreateManyWithoutFoliosInput `json:"shares,omitempty"`
}

type FolioCreateInput struct {
	Name      string                             `json:"name"`
	Desc      string                             `json:"desc"`
	Thumbnail *ThumbnailCreateOneInput           `json:"thumbnail,omitempty"`
	Assets    *AssetCreateManyWithoutFolioInput  `json:"assets,omitempty"`
	Links     *LinkCreateManyWithoutFolioInput   `json:"links,omitempty"`
	Notes     *NoteCreateManyWithoutFolioInput   `json:"notes,omitempty"`
	Owner     UserCreateOneInput                 `json:"owner"`
	Tags      *TagCreateManyWithoutFoliosInput   `json:"tags,omitempty"`
	Shares    *ShareCreateManyWithoutFoliosInput `json:"shares,omitempty"`
}

type FolioUpdateManyDataInput struct {
	Name *string `json:"name,omitempty"`
	Desc *string `json:"desc,omitempty"`
}

type AssetCreateManyWithoutFolioInput struct {
	Create  []AssetCreateWithoutFolioInput `json:"create,omitempty"`
	Connect []AssetWhereUniqueInput        `json:"connect,omitempty"`
}

type FolioUpsertWithWhereUniqueWithoutSharesInput struct {
	Where  FolioWhereUniqueInput             `json:"where"`
	Update FolioUpdateWithoutSharesDataInput `json:"update"`
	Create FolioCreateWithoutSharesInput     `json:"create"`
}

type AssetCreateWithoutFolioInput struct {
	Name      string                   `json:"name"`
	Uuid      *string                  `json:"uuid,omitempty"`
	Path      *string                  `json:"path,omitempty"`
	Note      *string                  `json:"note,omitempty"`
	MimeType  *string                  `json:"mimeType,omitempty"`
	Thumbnail *ThumbnailCreateOneInput `json:"thumbnail,omitempty"`
}

type FolioUpdateManyWithoutSharesInput struct {
	Create     []FolioCreateWithoutSharesInput                `json:"create,omitempty"`
	Delete     []FolioWhereUniqueInput                        `json:"delete,omitempty"`
	Connect    []FolioWhereUniqueInput                        `json:"connect,omitempty"`
	Set        []FolioWhereUniqueInput                        `json:"set,omitempty"`
	Disconnect []FolioWhereUniqueInput                        `json:"disconnect,omitempty"`
	Update     []FolioUpdateWithWhereUniqueWithoutSharesInput `json:"update,omitempty"`
	Upsert     []FolioUpsertWithWhereUniqueWithoutSharesInput `json:"upsert,omitempty"`
	DeleteMany []FolioScalarWhereInput                        `json:"deleteMany,omitempty"`
	UpdateMany []FolioUpdateManyWithWhereNestedInput          `json:"updateMany,omitempty"`
}

type FolioUpdateInput struct {
	Name      *string                            `json:"name,omitempty"`
	Desc      *string                            `json:"desc,omitempty"`
	Thumbnail *ThumbnailUpdateOneInput           `json:"thumbnail,omitempty"`
	Assets    *AssetUpdateManyWithoutFolioInput  `json:"assets,omitempty"`
	Links     *LinkUpdateManyWithoutFolioInput   `json:"links,omitempty"`
	Notes     *NoteUpdateManyWithoutFolioInput   `json:"notes,omitempty"`
	Owner     *UserUpdateOneRequiredInput        `json:"owner,omitempty"`
	Tags      *TagUpdateManyWithoutFoliosInput   `json:"tags,omitempty"`
	Shares    *ShareUpdateManyWithoutFoliosInput `json:"shares,omitempty"`
}

type FolioCreateManyWithoutSharesInput struct {
	Create  []FolioCreateWithoutSharesInput `json:"create,omitempty"`
	Connect []FolioWhereUniqueInput         `json:"connect,omitempty"`
}

type AssetUpdateManyWithoutFolioInput struct {
	Create     []AssetCreateWithoutFolioInput                `json:"create,omitempty"`
	Delete     []AssetWhereUniqueInput                       `json:"delete,omitempty"`
	Connect    []AssetWhereUniqueInput                       `json:"connect,omitempty"`
	Set        []AssetWhereUniqueInput                       `json:"set,omitempty"`
	Disconnect []AssetWhereUniqueInput                       `json:"disconnect,omitempty"`
	Update     []AssetUpdateWithWhereUniqueWithoutFolioInput `json:"update,omitempty"`
	Upsert     []AssetUpsertWithWhereUniqueWithoutFolioInput `json:"upsert,omitempty"`
	DeleteMany []AssetScalarWhereInput                       `json:"deleteMany,omitempty"`
	UpdateMany []AssetUpdateManyWithWhereNestedInput         `json:"updateMany,omitempty"`
}

type UserUpsertWithoutPostsInput struct {
	Update UserUpdateWithoutPostsDataInput `json:"update"`
	Create UserCreateWithoutPostsInput     `json:"create"`
}

type AssetUpdateWithWhereUniqueWithoutFolioInput struct {
	Where AssetWhereUniqueInput            `json:"where"`
	Data  AssetUpdateWithoutFolioDataInput `json:"data"`
}

type FolioCreateOneWithoutAssetsInput struct {
	Create  *FolioCreateWithoutAssetsInput `json:"create,omitempty"`
	Connect *FolioWhereUniqueInput         `json:"connect,omitempty"`
}

type AssetUpdateWithoutFolioDataInput struct {
	Name      *string                  `json:"name,omitempty"`
	Uuid      *string                  `json:"uuid,omitempty"`
	Path      *string                  `json:"path,omitempty"`
	Note      *string                  `json:"note,omitempty"`
	MimeType  *string                  `json:"mimeType,omitempty"`
	Thumbnail *ThumbnailUpdateOneInput `json:"thumbnail,omitempty"`
}

type NoteCreateManyWithoutFolioInput struct {
	Create  []NoteCreateWithoutFolioInput `json:"create,omitempty"`
	Connect []NoteWhereUniqueInput        `json:"connect,omitempty"`
}

type AssetUpsertWithWhereUniqueWithoutFolioInput struct {
	Where  AssetWhereUniqueInput            `json:"where"`
	Update AssetUpdateWithoutFolioDataInput `json:"update"`
	Create AssetCreateWithoutFolioInput     `json:"create"`
}

type PostCreateManyWithoutAuthorInput struct {
	Create  []PostCreateWithoutAuthorInput `json:"create,omitempty"`
	Connect []PostWhereUniqueInput         `json:"connect,omitempty"`
}

type AssetScalarWhereInput struct {
	ID                    *string                 `json:"id,omitempty"`
	IDNot                 *string                 `json:"id_not,omitempty"`
	IDIn                  []string                `json:"id_in,omitempty"`
	IDNotIn               []string                `json:"id_not_in,omitempty"`
	IDLt                  *string                 `json:"id_lt,omitempty"`
	IDLte                 *string                 `json:"id_lte,omitempty"`
	IDGt                  *string                 `json:"id_gt,omitempty"`
	IDGte                 *string                 `json:"id_gte,omitempty"`
	IDContains            *string                 `json:"id_contains,omitempty"`
	IDNotContains         *string                 `json:"id_not_contains,omitempty"`
	IDStartsWith          *string                 `json:"id_starts_with,omitempty"`
	IDNotStartsWith       *string                 `json:"id_not_starts_with,omitempty"`
	IDEndsWith            *string                 `json:"id_ends_with,omitempty"`
	IDNotEndsWith         *string                 `json:"id_not_ends_with,omitempty"`
	Name                  *string                 `json:"name,omitempty"`
	NameNot               *string                 `json:"name_not,omitempty"`
	NameIn                []string                `json:"name_in,omitempty"`
	NameNotIn             []string                `json:"name_not_in,omitempty"`
	NameLt                *string                 `json:"name_lt,omitempty"`
	NameLte               *string                 `json:"name_lte,omitempty"`
	NameGt                *string                 `json:"name_gt,omitempty"`
	NameGte               *string                 `json:"name_gte,omitempty"`
	NameContains          *string                 `json:"name_contains,omitempty"`
	NameNotContains       *string                 `json:"name_not_contains,omitempty"`
	NameStartsWith        *string                 `json:"name_starts_with,omitempty"`
	NameNotStartsWith     *string                 `json:"name_not_starts_with,omitempty"`
	NameEndsWith          *string                 `json:"name_ends_with,omitempty"`
	NameNotEndsWith       *string                 `json:"name_not_ends_with,omitempty"`
	Uuid                  *string                 `json:"uuid,omitempty"`
	UuidNot               *string                 `json:"uuid_not,omitempty"`
	UuidIn                []string                `json:"uuid_in,omitempty"`
	UuidNotIn             []string                `json:"uuid_not_in,omitempty"`
	UuidLt                *string                 `json:"uuid_lt,omitempty"`
	UuidLte               *string                 `json:"uuid_lte,omitempty"`
	UuidGt                *string                 `json:"uuid_gt,omitempty"`
	UuidGte               *string                 `json:"uuid_gte,omitempty"`
	UuidContains          *string                 `json:"uuid_contains,omitempty"`
	UuidNotContains       *string                 `json:"uuid_not_contains,omitempty"`
	UuidStartsWith        *string                 `json:"uuid_starts_with,omitempty"`
	UuidNotStartsWith     *string                 `json:"uuid_not_starts_with,omitempty"`
	UuidEndsWith          *string                 `json:"uuid_ends_with,omitempty"`
	UuidNotEndsWith       *string                 `json:"uuid_not_ends_with,omitempty"`
	Path                  *string                 `json:"path,omitempty"`
	PathNot               *string                 `json:"path_not,omitempty"`
	PathIn                []string                `json:"path_in,omitempty"`
	PathNotIn             []string                `json:"path_not_in,omitempty"`
	PathLt                *string                 `json:"path_lt,omitempty"`
	PathLte               *string                 `json:"path_lte,omitempty"`
	PathGt                *string                 `json:"path_gt,omitempty"`
	PathGte               *string                 `json:"path_gte,omitempty"`
	PathContains          *string                 `json:"path_contains,omitempty"`
	PathNotContains       *string                 `json:"path_not_contains,omitempty"`
	PathStartsWith        *string                 `json:"path_starts_with,omitempty"`
	PathNotStartsWith     *string                 `json:"path_not_starts_with,omitempty"`
	PathEndsWith          *string                 `json:"path_ends_with,omitempty"`
	PathNotEndsWith       *string                 `json:"path_not_ends_with,omitempty"`
	Note                  *string                 `json:"note,omitempty"`
	NoteNot               *string                 `json:"note_not,omitempty"`
	NoteIn                []string                `json:"note_in,omitempty"`
	NoteNotIn             []string                `json:"note_not_in,omitempty"`
	NoteLt                *string                 `json:"note_lt,omitempty"`
	NoteLte               *string                 `json:"note_lte,omitempty"`
	NoteGt                *string                 `json:"note_gt,omitempty"`
	NoteGte               *string                 `json:"note_gte,omitempty"`
	NoteContains          *string                 `json:"note_contains,omitempty"`
	NoteNotContains       *string                 `json:"note_not_contains,omitempty"`
	NoteStartsWith        *string                 `json:"note_starts_with,omitempty"`
	NoteNotStartsWith     *string                 `json:"note_not_starts_with,omitempty"`
	NoteEndsWith          *string                 `json:"note_ends_with,omitempty"`
	NoteNotEndsWith       *string                 `json:"note_not_ends_with,omitempty"`
	MimeType              *string                 `json:"mimeType,omitempty"`
	MimeTypeNot           *string                 `json:"mimeType_not,omitempty"`
	MimeTypeIn            []string                `json:"mimeType_in,omitempty"`
	MimeTypeNotIn         []string                `json:"mimeType_not_in,omitempty"`
	MimeTypeLt            *string                 `json:"mimeType_lt,omitempty"`
	MimeTypeLte           *string                 `json:"mimeType_lte,omitempty"`
	MimeTypeGt            *string                 `json:"mimeType_gt,omitempty"`
	MimeTypeGte           *string                 `json:"mimeType_gte,omitempty"`
	MimeTypeContains      *string                 `json:"mimeType_contains,omitempty"`
	MimeTypeNotContains   *string                 `json:"mimeType_not_contains,omitempty"`
	MimeTypeStartsWith    *string                 `json:"mimeType_starts_with,omitempty"`
	MimeTypeNotStartsWith *string                 `json:"mimeType_not_starts_with,omitempty"`
	MimeTypeEndsWith      *string                 `json:"mimeType_ends_with,omitempty"`
	MimeTypeNotEndsWith   *string                 `json:"mimeType_not_ends_with,omitempty"`
	And                   []AssetScalarWhereInput `json:"AND,omitempty"`
	Or                    []AssetScalarWhereInput `json:"OR,omitempty"`
	Not                   []AssetScalarWhereInput `json:"NOT,omitempty"`
}

type ShareCreateManyWithoutFoliosInput struct {
	Create  []ShareCreateWithoutFoliosInput `json:"create,omitempty"`
	Connect []ShareWhereUniqueInput         `json:"connect,omitempty"`
}

type AssetUpdateManyWithWhereNestedInput struct {
	Where AssetScalarWhereInput    `json:"where"`
	Data  AssetUpdateManyDataInput `json:"data"`
}

type NoteWhereInput struct {
	ID                *string              `json:"id,omitempty"`
	IDNot             *string              `json:"id_not,omitempty"`
	IDIn              []string             `json:"id_in,omitempty"`
	IDNotIn           []string             `json:"id_not_in,omitempty"`
	IDLt              *string              `json:"id_lt,omitempty"`
	IDLte             *string              `json:"id_lte,omitempty"`
	IDGt              *string              `json:"id_gt,omitempty"`
	IDGte             *string              `json:"id_gte,omitempty"`
	IDContains        *string              `json:"id_contains,omitempty"`
	IDNotContains     *string              `json:"id_not_contains,omitempty"`
	IDStartsWith      *string              `json:"id_starts_with,omitempty"`
	IDNotStartsWith   *string              `json:"id_not_starts_with,omitempty"`
	IDEndsWith        *string              `json:"id_ends_with,omitempty"`
	IDNotEndsWith     *string              `json:"id_not_ends_with,omitempty"`
	Name              *string              `json:"name,omitempty"`
	NameNot           *string              `json:"name_not,omitempty"`
	NameIn            []string             `json:"name_in,omitempty"`
	NameNotIn         []string             `json:"name_not_in,omitempty"`
	NameLt            *string              `json:"name_lt,omitempty"`
	NameLte           *string              `json:"name_lte,omitempty"`
	NameGt            *string              `json:"name_gt,omitempty"`
	NameGte           *string              `json:"name_gte,omitempty"`
	NameContains      *string              `json:"name_contains,omitempty"`
	NameNotContains   *string              `json:"name_not_contains,omitempty"`
	NameStartsWith    *string              `json:"name_starts_with,omitempty"`
	NameNotStartsWith *string              `json:"name_not_starts_with,omitempty"`
	NameEndsWith      *string              `json:"name_ends_with,omitempty"`
	NameNotEndsWith   *string              `json:"name_not_ends_with,omitempty"`
	Note              *string              `json:"note,omitempty"`
	NoteNot           *string              `json:"note_not,omitempty"`
	NoteIn            []string             `json:"note_in,omitempty"`
	NoteNotIn         []string             `json:"note_not_in,omitempty"`
	NoteLt            *string              `json:"note_lt,omitempty"`
	NoteLte           *string              `json:"note_lte,omitempty"`
	NoteGt            *string              `json:"note_gt,omitempty"`
	NoteGte           *string              `json:"note_gte,omitempty"`
	NoteContains      *string              `json:"note_contains,omitempty"`
	NoteNotContains   *string              `json:"note_not_contains,omitempty"`
	NoteStartsWith    *string              `json:"note_starts_with,omitempty"`
	NoteNotStartsWith *string              `json:"note_not_starts_with,omitempty"`
	NoteEndsWith      *string              `json:"note_ends_with,omitempty"`
	NoteNotEndsWith   *string              `json:"note_not_ends_with,omitempty"`
	Thumbnail         *ThumbnailWhereInput `json:"thumbnail,omitempty"`
	Folio             *FolioWhereInput     `json:"folio,omitempty"`
	And               []NoteWhereInput     `json:"AND,omitempty"`
	Or                []NoteWhereInput     `json:"OR,omitempty"`
	Not               []NoteWhereInput     `json:"NOT,omitempty"`
}

type AssetUpdateManyDataInput struct {
	Name     *string `json:"name,omitempty"`
	Uuid     *string `json:"uuid,omitempty"`
	Path     *string `json:"path,omitempty"`
	Note     *string `json:"note,omitempty"`
	MimeType *string `json:"mimeType,omitempty"`
}

type NoteSubscriptionWhereInput struct {
	MutationIn                 []MutationType               `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                      `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                     `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                     `json:"updatedFields_contains_some,omitempty"`
	Node                       *NoteWhereInput              `json:"node,omitempty"`
	And                        []NoteSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []NoteSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []NoteSubscriptionWhereInput `json:"NOT,omitempty"`
}

type FolioUpdateManyMutationInput struct {
	Name *string `json:"name,omitempty"`
	Desc *string `json:"desc,omitempty"`
}

type FolioWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type LinkCreateInput struct {
	Name      string                           `json:"name"`
	Desc      *string                          `json:"desc,omitempty"`
	Url       *string                          `json:"url,omitempty"`
	Thumbnail *ThumbnailCreateOneInput         `json:"thumbnail,omitempty"`
	Folio     *FolioCreateOneWithoutLinksInput `json:"folio,omitempty"`
}

type NoteWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type FolioCreateOneWithoutLinksInput struct {
	Create  *FolioCreateWithoutLinksInput `json:"create,omitempty"`
	Connect *FolioWhereUniqueInput        `json:"connect,omitempty"`
}

type ShareWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type FolioCreateWithoutLinksInput struct {
	Name      string                             `json:"name"`
	Desc      string                             `json:"desc"`
	Thumbnail *ThumbnailCreateOneInput           `json:"thumbnail,omitempty"`
	Assets    *AssetCreateManyWithoutFolioInput  `json:"assets,omitempty"`
	Notes     *NoteCreateManyWithoutFolioInput   `json:"notes,omitempty"`
	Owner     UserCreateOneInput                 `json:"owner"`
	Tags      *TagCreateManyWithoutFoliosInput   `json:"tags,omitempty"`
	Shares    *ShareCreateManyWithoutFoliosInput `json:"shares,omitempty"`
}

type ThumbnailWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type LinkUpdateInput struct {
	Name      *string                          `json:"name,omitempty"`
	Desc      *string                          `json:"desc,omitempty"`
	Url       *string                          `json:"url,omitempty"`
	Thumbnail *ThumbnailUpdateOneInput         `json:"thumbnail,omitempty"`
	Folio     *FolioUpdateOneWithoutLinksInput `json:"folio,omitempty"`
}

type UserUpdateOneWithoutPostsInput struct {
	Create     *UserCreateWithoutPostsInput     `json:"create,omitempty"`
	Update     *UserUpdateWithoutPostsDataInput `json:"update,omitempty"`
	Upsert     *UserUpsertWithoutPostsInput     `json:"upsert,omitempty"`
	Delete     *bool                            `json:"delete,omitempty"`
	Disconnect *bool                            `json:"disconnect,omitempty"`
	Connect    *UserWhereUniqueInput            `json:"connect,omitempty"`
}

type FolioUpdateOneWithoutLinksInput struct {
	Create     *FolioCreateWithoutLinksInput     `json:"create,omitempty"`
	Update     *FolioUpdateWithoutLinksDataInput `json:"update,omitempty"`
	Upsert     *FolioUpsertWithoutLinksInput     `json:"upsert,omitempty"`
	Delete     *bool                             `json:"delete,omitempty"`
	Disconnect *bool                             `json:"disconnect,omitempty"`
	Connect    *FolioWhereUniqueInput            `json:"connect,omitempty"`
}

type LinkCreateManyWithoutFolioInput struct {
	Create  []LinkCreateWithoutFolioInput `json:"create,omitempty"`
	Connect []LinkWhereUniqueInput        `json:"connect,omitempty"`
}

type FolioUpdateWithoutLinksDataInput struct {
	Name      *string                            `json:"name,omitempty"`
	Desc      *string                            `json:"desc,omitempty"`
	Thumbnail *ThumbnailUpdateOneInput           `json:"thumbnail,omitempty"`
	Assets    *AssetUpdateManyWithoutFolioInput  `json:"assets,omitempty"`
	Notes     *NoteUpdateManyWithoutFolioInput   `json:"notes,omitempty"`
	Owner     *UserUpdateOneRequiredInput        `json:"owner,omitempty"`
	Tags      *TagUpdateManyWithoutFoliosInput   `json:"tags,omitempty"`
	Shares    *ShareUpdateManyWithoutFoliosInput `json:"shares,omitempty"`
}

type TagCreateManyWithoutFoliosInput struct {
	Create  []TagCreateWithoutFoliosInput `json:"create,omitempty"`
	Connect []TagWhereUniqueInput         `json:"connect,omitempty"`
}

type FolioUpsertWithoutLinksInput struct {
	Update FolioUpdateWithoutLinksDataInput `json:"update"`
	Create FolioCreateWithoutLinksInput     `json:"create"`
}

type ShareSubscriptionWhereInput struct {
	MutationIn                 []MutationType                `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                       `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                      `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                      `json:"updatedFields_contains_some,omitempty"`
	Node                       *ShareWhereInput              `json:"node,omitempty"`
	And                        []ShareSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []ShareSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []ShareSubscriptionWhereInput `json:"NOT,omitempty"`
}

type LinkUpdateManyMutationInput struct {
	Name *string `json:"name,omitempty"`
	Desc *string `json:"desc,omitempty"`
	Url  *string `json:"url,omitempty"`
}

type LinkWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type NoteCreateInput struct {
	Name      string                           `json:"name"`
	Note      *string                          `json:"note,omitempty"`
	Thumbnail *ThumbnailCreateOneInput         `json:"thumbnail,omitempty"`
	Folio     *FolioCreateOneWithoutNotesInput `json:"folio,omitempty"`
}

type TagWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type FolioCreateOneWithoutNotesInput struct {
	Create  *FolioCreateWithoutNotesInput `json:"create,omitempty"`
	Connect *FolioWhereUniqueInput        `json:"connect,omitempty"`
}

type ThumbnailCreateOneInput struct {
	Create  *ThumbnailCreateInput      `json:"create,omitempty"`
	Connect *ThumbnailWhereUniqueInput `json:"connect,omitempty"`
}

type FolioCreateWithoutNotesInput struct {
	Name      string                             `json:"name"`
	Desc      string                             `json:"desc"`
	Thumbnail *ThumbnailCreateOneInput           `json:"thumbnail,omitempty"`
	Assets    *AssetCreateManyWithoutFolioInput  `json:"assets,omitempty"`
	Links     *LinkCreateManyWithoutFolioInput   `json:"links,omitempty"`
	Owner     UserCreateOneInput                 `json:"owner"`
	Tags      *TagCreateManyWithoutFoliosInput   `json:"tags,omitempty"`
	Shares    *ShareCreateManyWithoutFoliosInput `json:"shares,omitempty"`
}

type PostWhereInput struct {
	ID                 *string          `json:"id,omitempty"`
	IDNot              *string          `json:"id_not,omitempty"`
	IDIn               []string         `json:"id_in,omitempty"`
	IDNotIn            []string         `json:"id_not_in,omitempty"`
	IDLt               *string          `json:"id_lt,omitempty"`
	IDLte              *string          `json:"id_lte,omitempty"`
	IDGt               *string          `json:"id_gt,omitempty"`
	IDGte              *string          `json:"id_gte,omitempty"`
	IDContains         *string          `json:"id_contains,omitempty"`
	IDNotContains      *string          `json:"id_not_contains,omitempty"`
	IDStartsWith       *string          `json:"id_starts_with,omitempty"`
	IDNotStartsWith    *string          `json:"id_not_starts_with,omitempty"`
	IDEndsWith         *string          `json:"id_ends_with,omitempty"`
	IDNotEndsWith      *string          `json:"id_not_ends_with,omitempty"`
	Title              *string          `json:"title,omitempty"`
	TitleNot           *string          `json:"title_not,omitempty"`
	TitleIn            []string         `json:"title_in,omitempty"`
	TitleNotIn         []string         `json:"title_not_in,omitempty"`
	TitleLt            *string          `json:"title_lt,omitempty"`
	TitleLte           *string          `json:"title_lte,omitempty"`
	TitleGt            *string          `json:"title_gt,omitempty"`
	TitleGte           *string          `json:"title_gte,omitempty"`
	TitleContains      *string          `json:"title_contains,omitempty"`
	TitleNotContains   *string          `json:"title_not_contains,omitempty"`
	TitleStartsWith    *string          `json:"title_starts_with,omitempty"`
	TitleNotStartsWith *string          `json:"title_not_starts_with,omitempty"`
	TitleEndsWith      *string          `json:"title_ends_with,omitempty"`
	TitleNotEndsWith   *string          `json:"title_not_ends_with,omitempty"`
	Published          *bool            `json:"published,omitempty"`
	PublishedNot       *bool            `json:"published_not,omitempty"`
	Author             *UserWhereInput  `json:"author,omitempty"`
	And                []PostWhereInput `json:"AND,omitempty"`
	Or                 []PostWhereInput `json:"OR,omitempty"`
	Not                []PostWhereInput `json:"NOT,omitempty"`
}

type FolioUpsertWithoutNotesInput struct {
	Update FolioUpdateWithoutNotesDataInput `json:"update"`
	Create FolioCreateWithoutNotesInput     `json:"create"`
}

type FolioUpdateWithoutNotesDataInput struct {
	Name      *string                            `json:"name,omitempty"`
	Desc      *string                            `json:"desc,omitempty"`
	Thumbnail *ThumbnailUpdateOneInput           `json:"thumbnail,omitempty"`
	Assets    *AssetUpdateManyWithoutFolioInput  `json:"assets,omitempty"`
	Links     *LinkUpdateManyWithoutFolioInput   `json:"links,omitempty"`
	Owner     *UserUpdateOneRequiredInput        `json:"owner,omitempty"`
	Tags      *TagUpdateManyWithoutFoliosInput   `json:"tags,omitempty"`
	Shares    *ShareUpdateManyWithoutFoliosInput `json:"shares,omitempty"`
}

type FolioUpdateOneWithoutNotesInput struct {
	Create     *FolioCreateWithoutNotesInput     `json:"create,omitempty"`
	Update     *FolioUpdateWithoutNotesDataInput `json:"update,omitempty"`
	Upsert     *FolioUpsertWithoutNotesInput     `json:"upsert,omitempty"`
	Delete     *bool                             `json:"delete,omitempty"`
	Disconnect *bool                             `json:"disconnect,omitempty"`
	Connect    *FolioWhereUniqueInput            `json:"connect,omitempty"`
}

type NoteUpdateInput struct {
	Name      *string                          `json:"name,omitempty"`
	Note      *string                          `json:"note,omitempty"`
	Thumbnail *ThumbnailUpdateOneInput         `json:"thumbnail,omitempty"`
	Folio     *FolioUpdateOneWithoutNotesInput `json:"folio,omitempty"`
}

type AssetSubscriptionWhereInput struct {
	MutationIn                 []MutationType                `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                       `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                      `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                      `json:"updatedFields_contains_some,omitempty"`
	Node                       *AssetWhereInput              `json:"node,omitempty"`
	And                        []AssetSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []AssetSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []AssetSubscriptionWhereInput `json:"NOT,omitempty"`
}

type UserCreateOneInput struct {
	Create  *UserCreateInput      `json:"create,omitempty"`
	Connect *UserWhereUniqueInput `json:"connect,omitempty"`
}

type PostUpdateManyMutationInput struct {
	Title     *string `json:"title,omitempty"`
	Published *bool   `json:"published,omitempty"`
}

type PostWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type UserPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance UserPreviousValuesExec) Exec(ctx context.Context) (*UserPreviousValues, error) {
	var v UserPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance UserPreviousValuesExecArray) Exec(ctx context.Context) ([]UserPreviousValues, error) {
	var v []UserPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type UserPreviousValues struct {
	ID        string  `json:"id"`
	Email     *string `json:"email,omitempty"`
	Firstname string  `json:"firstname"`
	Lastname  string  `json:"lastname"`
}

type FolioConnectionExec struct {
	exec *prisma.Exec
}

func (instance *FolioConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *FolioConnectionExec) Edges() *FolioEdgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "FolioEdge"},
		"edges",
		[]string{"cursor"})

	return &FolioEdgeExec{ret}
}

func (instance *FolioConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateFolio"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return v, err
}

func (instance FolioConnectionExec) Exec(ctx context.Context) (*FolioConnection, error) {
	var v FolioConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance FolioConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type FolioConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance FolioConnectionExecArray) Exec(ctx context.Context) ([]FolioConnection, error) {
	var v []FolioConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type FolioConnection struct {
}

type ThumbnailSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *ThumbnailSubscriptionPayloadExec) Node() *ThumbnailExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Thumbnail"},
		"node",
		[]string{"id", "name", "path"})

	return &ThumbnailExec{ret}
}

func (instance *ThumbnailSubscriptionPayloadExec) PreviousValues() *ThumbnailPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ThumbnailPreviousValues"},
		"previousValues",
		[]string{"id", "name", "path"})

	return &ThumbnailPreviousValuesExec{ret}
}

func (instance ThumbnailSubscriptionPayloadExec) Exec(ctx context.Context) (*ThumbnailSubscriptionPayload, error) {
	var v ThumbnailSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ThumbnailSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ThumbnailSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance ThumbnailSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]ThumbnailSubscriptionPayload, error) {
	var v []ThumbnailSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type ThumbnailSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type AssetEdgeExec struct {
	exec *prisma.Exec
}

func (instance *AssetEdgeExec) Node() *AssetExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Asset"},
		"node",
		[]string{"id", "name", "uuid", "path", "note", "mimeType"})

	return &AssetExec{ret}
}

func (instance AssetEdgeExec) Exec(ctx context.Context) (*AssetEdge, error) {
	var v AssetEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AssetEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AssetEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance AssetEdgeExecArray) Exec(ctx context.Context) ([]AssetEdge, error) {
	var v []AssetEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type AssetEdge struct {
	Cursor string `json:"cursor"`
}

type PageInfoExec struct {
	exec *prisma.Exec
}

func (instance PageInfoExec) Exec(ctx context.Context) (*PageInfo, error) {
	var v PageInfo
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PageInfoExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PageInfoExecArray struct {
	exec *prisma.Exec
}

func (instance PageInfoExecArray) Exec(ctx context.Context) ([]PageInfo, error) {
	var v []PageInfo
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PageInfo struct {
	HasNextPage     bool    `json:"hasNextPage"`
	HasPreviousPage bool    `json:"hasPreviousPage"`
	StartCursor     *string `json:"startCursor,omitempty"`
	EndCursor       *string `json:"endCursor,omitempty"`
}

type UserConnectionExec struct {
	exec *prisma.Exec
}

func (instance *UserConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *UserConnectionExec) Edges() *UserEdgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "UserEdge"},
		"edges",
		[]string{"cursor"})

	return &UserEdgeExec{ret}
}

func (instance *UserConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateUser"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return v, err
}

func (instance UserConnectionExec) Exec(ctx context.Context) (*UserConnection, error) {
	var v UserConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance UserConnectionExecArray) Exec(ctx context.Context) ([]UserConnection, error) {
	var v []UserConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type UserConnection struct {
}

type AssetConnectionExec struct {
	exec *prisma.Exec
}

func (instance *AssetConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *AssetConnectionExec) Edges() *AssetEdgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AssetEdge"},
		"edges",
		[]string{"cursor"})

	return &AssetEdgeExec{ret}
}

func (instance *AssetConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateAsset"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return v, err
}

func (instance AssetConnectionExec) Exec(ctx context.Context) (*AssetConnection, error) {
	var v AssetConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AssetConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AssetConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance AssetConnectionExecArray) Exec(ctx context.Context) ([]AssetConnection, error) {
	var v []AssetConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type AssetConnection struct {
}

type AssetExec struct {
	exec *prisma.Exec
}

func (instance *AssetExec) Thumbnail() *ThumbnailExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Thumbnail"},
		"thumbnail",
		[]string{"id", "name", "path"})

	return &ThumbnailExec{ret}
}

func (instance *AssetExec) Folio() *FolioExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Folio"},
		"folio",
		[]string{"id", "name", "desc"})

	return &FolioExec{ret}
}

func (instance AssetExec) Exec(ctx context.Context) (*Asset, error) {
	var v Asset
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AssetExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AssetExecArray struct {
	exec *prisma.Exec
}

func (instance AssetExecArray) Exec(ctx context.Context) ([]Asset, error) {
	var v []Asset
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Asset struct {
	ID       string  `json:"id"`
	Name     string  `json:"name"`
	Uuid     *string `json:"uuid,omitempty"`
	Path     *string `json:"path,omitempty"`
	Note     *string `json:"note,omitempty"`
	MimeType *string `json:"mimeType,omitempty"`
}

type ThumbnailConnectionExec struct {
	exec *prisma.Exec
}

func (instance *ThumbnailConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *ThumbnailConnectionExec) Edges() *ThumbnailEdgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ThumbnailEdge"},
		"edges",
		[]string{"cursor"})

	return &ThumbnailEdgeExec{ret}
}

func (instance *ThumbnailConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateThumbnail"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return v, err
}

func (instance ThumbnailConnectionExec) Exec(ctx context.Context) (*ThumbnailConnection, error) {
	var v ThumbnailConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ThumbnailConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ThumbnailConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance ThumbnailConnectionExecArray) Exec(ctx context.Context) ([]ThumbnailConnection, error) {
	var v []ThumbnailConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type ThumbnailConnection struct {
}

type AssetSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *AssetSubscriptionPayloadExec) Node() *AssetExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Asset"},
		"node",
		[]string{"id", "name", "uuid", "path", "note", "mimeType"})

	return &AssetExec{ret}
}

func (instance *AssetSubscriptionPayloadExec) PreviousValues() *AssetPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AssetPreviousValues"},
		"previousValues",
		[]string{"id", "name", "uuid", "path", "note", "mimeType"})

	return &AssetPreviousValuesExec{ret}
}

func (instance AssetSubscriptionPayloadExec) Exec(ctx context.Context) (*AssetSubscriptionPayload, error) {
	var v AssetSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AssetSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AssetSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance AssetSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]AssetSubscriptionPayload, error) {
	var v []AssetSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type AssetSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type AssetPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance AssetPreviousValuesExec) Exec(ctx context.Context) (*AssetPreviousValues, error) {
	var v AssetPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AssetPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AssetPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance AssetPreviousValuesExecArray) Exec(ctx context.Context) ([]AssetPreviousValues, error) {
	var v []AssetPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type AssetPreviousValues struct {
	ID       string  `json:"id"`
	Name     string  `json:"name"`
	Uuid     *string `json:"uuid,omitempty"`
	Path     *string `json:"path,omitempty"`
	Note     *string `json:"note,omitempty"`
	MimeType *string `json:"mimeType,omitempty"`
}

type TagConnectionExec struct {
	exec *prisma.Exec
}

func (instance *TagConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *TagConnectionExec) Edges() *TagEdgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "TagEdge"},
		"edges",
		[]string{"cursor"})

	return &TagEdgeExec{ret}
}

func (instance *TagConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateTag"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return v, err
}

func (instance TagConnectionExec) Exec(ctx context.Context) (*TagConnection, error) {
	var v TagConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TagConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TagConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance TagConnectionExecArray) Exec(ctx context.Context) ([]TagConnection, error) {
	var v []TagConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type TagConnection struct {
}

type ShareExec struct {
	exec *prisma.Exec
}

func (instance *ShareExec) Owner() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"owner",
		[]string{"id", "email", "firstname", "lastname"})

	return &UserExec{ret}
}

func (instance *ShareExec) Friend() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"friend",
		[]string{"id", "email", "firstname", "lastname"})

	return &UserExec{ret}
}

func (instance *ShareExec) Thumbnail() *ThumbnailExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Thumbnail"},
		"thumbnail",
		[]string{"id", "name", "path"})

	return &ThumbnailExec{ret}
}

type FoliosParamsExec struct {
	Where   *FolioWhereInput
	OrderBy *FolioOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *ShareExec) Folios(params *FoliosParamsExec) *FolioExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"FolioWhereInput", "FolioOrderByInput", "Folio"},
		"folios",
		[]string{"id", "name", "desc"})

	return &FolioExecArray{ret}
}

func (instance ShareExec) Exec(ctx context.Context) (*Share, error) {
	var v Share
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ShareExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ShareExecArray struct {
	exec *prisma.Exec
}

func (instance ShareExecArray) Exec(ctx context.Context) ([]Share, error) {
	var v []Share
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Share struct {
	ID string `json:"id"`
}

type ShareEdgeExec struct {
	exec *prisma.Exec
}

func (instance *ShareEdgeExec) Node() *ShareExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Share"},
		"node",
		[]string{"id"})

	return &ShareExec{ret}
}

func (instance ShareEdgeExec) Exec(ctx context.Context) (*ShareEdge, error) {
	var v ShareEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ShareEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ShareEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance ShareEdgeExecArray) Exec(ctx context.Context) ([]ShareEdge, error) {
	var v []ShareEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type ShareEdge struct {
	Cursor string `json:"cursor"`
}

type FolioSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *FolioSubscriptionPayloadExec) Node() *FolioExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Folio"},
		"node",
		[]string{"id", "name", "desc"})

	return &FolioExec{ret}
}

func (instance *FolioSubscriptionPayloadExec) PreviousValues() *FolioPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "FolioPreviousValues"},
		"previousValues",
		[]string{"id", "name", "desc"})

	return &FolioPreviousValuesExec{ret}
}

func (instance FolioSubscriptionPayloadExec) Exec(ctx context.Context) (*FolioSubscriptionPayload, error) {
	var v FolioSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance FolioSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type FolioSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance FolioSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]FolioSubscriptionPayload, error) {
	var v []FolioSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type FolioSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type FolioPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance FolioPreviousValuesExec) Exec(ctx context.Context) (*FolioPreviousValues, error) {
	var v FolioPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance FolioPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type FolioPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance FolioPreviousValuesExecArray) Exec(ctx context.Context) ([]FolioPreviousValues, error) {
	var v []FolioPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type FolioPreviousValues struct {
	ID   string `json:"id"`
	Name string `json:"name"`
	Desc string `json:"desc"`
}

type PostConnectionExec struct {
	exec *prisma.Exec
}

func (instance *PostConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *PostConnectionExec) Edges() *PostEdgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PostEdge"},
		"edges",
		[]string{"cursor"})

	return &PostEdgeExec{ret}
}

func (instance *PostConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregatePost"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return v, err
}

func (instance PostConnectionExec) Exec(ctx context.Context) (*PostConnection, error) {
	var v PostConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PostConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PostConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance PostConnectionExecArray) Exec(ctx context.Context) ([]PostConnection, error) {
	var v []PostConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PostConnection struct {
}

type FolioExec struct {
	exec *prisma.Exec
}

func (instance *FolioExec) Thumbnail() *ThumbnailExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Thumbnail"},
		"thumbnail",
		[]string{"id", "name", "path"})

	return &ThumbnailExec{ret}
}

type AssetsParamsExec struct {
	Where   *AssetWhereInput
	OrderBy *AssetOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *FolioExec) Assets(params *AssetsParamsExec) *AssetExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"AssetWhereInput", "AssetOrderByInput", "Asset"},
		"assets",
		[]string{"id", "name", "uuid", "path", "note", "mimeType"})

	return &AssetExecArray{ret}
}

type LinksParamsExec struct {
	Where   *LinkWhereInput
	OrderBy *LinkOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *FolioExec) Links(params *LinksParamsExec) *LinkExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"LinkWhereInput", "LinkOrderByInput", "Link"},
		"links",
		[]string{"id", "name", "desc", "url"})

	return &LinkExecArray{ret}
}

type NotesParamsExec struct {
	Where   *NoteWhereInput
	OrderBy *NoteOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *FolioExec) Notes(params *NotesParamsExec) *NoteExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"NoteWhereInput", "NoteOrderByInput", "Note"},
		"notes",
		[]string{"id", "name", "note"})

	return &NoteExecArray{ret}
}

func (instance *FolioExec) Owner() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"owner",
		[]string{"id", "email", "firstname", "lastname"})

	return &UserExec{ret}
}

type TagsParamsExec struct {
	Where   *TagWhereInput
	OrderBy *TagOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *FolioExec) Tags(params *TagsParamsExec) *TagExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"TagWhereInput", "TagOrderByInput", "Tag"},
		"tags",
		[]string{"id", "kind", "name", "desc"})

	return &TagExecArray{ret}
}

type SharesParamsExec struct {
	Where   *ShareWhereInput
	OrderBy *ShareOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *FolioExec) Shares(params *SharesParamsExec) *ShareExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"ShareWhereInput", "ShareOrderByInput", "Share"},
		"shares",
		[]string{"id"})

	return &ShareExecArray{ret}
}

func (instance FolioExec) Exec(ctx context.Context) (*Folio, error) {
	var v Folio
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance FolioExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type FolioExecArray struct {
	exec *prisma.Exec
}

func (instance FolioExecArray) Exec(ctx context.Context) ([]Folio, error) {
	var v []Folio
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Folio struct {
	ID   string `json:"id"`
	Name string `json:"name"`
	Desc string `json:"desc"`
}

type NoteEdgeExec struct {
	exec *prisma.Exec
}

func (instance *NoteEdgeExec) Node() *NoteExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Note"},
		"node",
		[]string{"id", "name", "note"})

	return &NoteExec{ret}
}

func (instance NoteEdgeExec) Exec(ctx context.Context) (*NoteEdge, error) {
	var v NoteEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance NoteEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type NoteEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance NoteEdgeExecArray) Exec(ctx context.Context) ([]NoteEdge, error) {
	var v []NoteEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type NoteEdge struct {
	Cursor string `json:"cursor"`
}

type LinkSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *LinkSubscriptionPayloadExec) Node() *LinkExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Link"},
		"node",
		[]string{"id", "name", "desc", "url"})

	return &LinkExec{ret}
}

func (instance *LinkSubscriptionPayloadExec) PreviousValues() *LinkPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "LinkPreviousValues"},
		"previousValues",
		[]string{"id", "name", "desc", "url"})

	return &LinkPreviousValuesExec{ret}
}

func (instance LinkSubscriptionPayloadExec) Exec(ctx context.Context) (*LinkSubscriptionPayload, error) {
	var v LinkSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance LinkSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type LinkSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance LinkSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]LinkSubscriptionPayload, error) {
	var v []LinkSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type LinkSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type LinkPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance LinkPreviousValuesExec) Exec(ctx context.Context) (*LinkPreviousValues, error) {
	var v LinkPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance LinkPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type LinkPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance LinkPreviousValuesExecArray) Exec(ctx context.Context) ([]LinkPreviousValues, error) {
	var v []LinkPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type LinkPreviousValues struct {
	ID   string  `json:"id"`
	Name string  `json:"name"`
	Desc *string `json:"desc,omitempty"`
	Url  *string `json:"url,omitempty"`
}

type LinkConnectionExec struct {
	exec *prisma.Exec
}

func (instance *LinkConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *LinkConnectionExec) Edges() *LinkEdgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "LinkEdge"},
		"edges",
		[]string{"cursor"})

	return &LinkEdgeExec{ret}
}

func (instance *LinkConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateLink"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return v, err
}

func (instance LinkConnectionExec) Exec(ctx context.Context) (*LinkConnection, error) {
	var v LinkConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance LinkConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type LinkConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance LinkConnectionExecArray) Exec(ctx context.Context) ([]LinkConnection, error) {
	var v []LinkConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type LinkConnection struct {
}

type TagExec struct {
	exec *prisma.Exec
}

func (instance *TagExec) Thumbnail() *ThumbnailExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Thumbnail"},
		"thumbnail",
		[]string{"id", "name", "path"})

	return &ThumbnailExec{ret}
}

func (instance *TagExec) Folios(params *FoliosParamsExec) *FolioExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"FolioWhereInput", "FolioOrderByInput", "Folio"},
		"folios",
		[]string{"id", "name", "desc"})

	return &FolioExecArray{ret}
}

func (instance TagExec) Exec(ctx context.Context) (*Tag, error) {
	var v Tag
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TagExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TagExecArray struct {
	exec *prisma.Exec
}

func (instance TagExecArray) Exec(ctx context.Context) ([]Tag, error) {
	var v []Tag
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Tag struct {
	ID   string   `json:"id"`
	Kind *TagType `json:"kind,omitempty"`
	Name string   `json:"name"`
	Desc string   `json:"desc"`
}

type FolioEdgeExec struct {
	exec *prisma.Exec
}

func (instance *FolioEdgeExec) Node() *FolioExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Folio"},
		"node",
		[]string{"id", "name", "desc"})

	return &FolioExec{ret}
}

func (instance FolioEdgeExec) Exec(ctx context.Context) (*FolioEdge, error) {
	var v FolioEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance FolioEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type FolioEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance FolioEdgeExecArray) Exec(ctx context.Context) ([]FolioEdge, error) {
	var v []FolioEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type FolioEdge struct {
	Cursor string `json:"cursor"`
}

type NoteSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *NoteSubscriptionPayloadExec) Node() *NoteExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Note"},
		"node",
		[]string{"id", "name", "note"})

	return &NoteExec{ret}
}

func (instance *NoteSubscriptionPayloadExec) PreviousValues() *NotePreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "NotePreviousValues"},
		"previousValues",
		[]string{"id", "name", "note"})

	return &NotePreviousValuesExec{ret}
}

func (instance NoteSubscriptionPayloadExec) Exec(ctx context.Context) (*NoteSubscriptionPayload, error) {
	var v NoteSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance NoteSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type NoteSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance NoteSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]NoteSubscriptionPayload, error) {
	var v []NoteSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type NoteSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type UserEdgeExec struct {
	exec *prisma.Exec
}

func (instance *UserEdgeExec) Node() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"node",
		[]string{"id", "email", "firstname", "lastname"})

	return &UserExec{ret}
}

func (instance UserEdgeExec) Exec(ctx context.Context) (*UserEdge, error) {
	var v UserEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance UserEdgeExecArray) Exec(ctx context.Context) ([]UserEdge, error) {
	var v []UserEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type UserEdge struct {
	Cursor string `json:"cursor"`
}

type NotePreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance NotePreviousValuesExec) Exec(ctx context.Context) (*NotePreviousValues, error) {
	var v NotePreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance NotePreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type NotePreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance NotePreviousValuesExecArray) Exec(ctx context.Context) ([]NotePreviousValues, error) {
	var v []NotePreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type NotePreviousValues struct {
	ID   string  `json:"id"`
	Name string  `json:"name"`
	Note *string `json:"note,omitempty"`
}

type ThumbnailEdgeExec struct {
	exec *prisma.Exec
}

func (instance *ThumbnailEdgeExec) Node() *ThumbnailExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Thumbnail"},
		"node",
		[]string{"id", "name", "path"})

	return &ThumbnailExec{ret}
}

func (instance ThumbnailEdgeExec) Exec(ctx context.Context) (*ThumbnailEdge, error) {
	var v ThumbnailEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ThumbnailEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ThumbnailEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance ThumbnailEdgeExecArray) Exec(ctx context.Context) ([]ThumbnailEdge, error) {
	var v []ThumbnailEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type ThumbnailEdge struct {
	Cursor string `json:"cursor"`
}

type PostExec struct {
	exec *prisma.Exec
}

func (instance *PostExec) Author() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"author",
		[]string{"id", "email", "firstname", "lastname"})

	return &UserExec{ret}
}

func (instance PostExec) Exec(ctx context.Context) (*Post, error) {
	var v Post
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PostExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PostExecArray struct {
	exec *prisma.Exec
}

func (instance PostExecArray) Exec(ctx context.Context) ([]Post, error) {
	var v []Post
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Post struct {
	ID        string `json:"id"`
	Title     string `json:"title"`
	Published bool   `json:"published"`
}

type TagEdgeExec struct {
	exec *prisma.Exec
}

func (instance *TagEdgeExec) Node() *TagExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Tag"},
		"node",
		[]string{"id", "kind", "name", "desc"})

	return &TagExec{ret}
}

func (instance TagEdgeExec) Exec(ctx context.Context) (*TagEdge, error) {
	var v TagEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TagEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TagEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance TagEdgeExecArray) Exec(ctx context.Context) ([]TagEdge, error) {
	var v []TagEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type TagEdge struct {
	Cursor string `json:"cursor"`
}

type PostSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *PostSubscriptionPayloadExec) Node() *PostExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Post"},
		"node",
		[]string{"id", "title", "published"})

	return &PostExec{ret}
}

func (instance *PostSubscriptionPayloadExec) PreviousValues() *PostPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PostPreviousValues"},
		"previousValues",
		[]string{"id", "title", "published"})

	return &PostPreviousValuesExec{ret}
}

func (instance PostSubscriptionPayloadExec) Exec(ctx context.Context) (*PostSubscriptionPayload, error) {
	var v PostSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PostSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PostSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance PostSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]PostSubscriptionPayload, error) {
	var v []PostSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PostSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type ShareConnectionExec struct {
	exec *prisma.Exec
}

func (instance *ShareConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *ShareConnectionExec) Edges() *ShareEdgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ShareEdge"},
		"edges",
		[]string{"cursor"})

	return &ShareEdgeExec{ret}
}

func (instance *ShareConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateShare"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return v, err
}

func (instance ShareConnectionExec) Exec(ctx context.Context) (*ShareConnection, error) {
	var v ShareConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ShareConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ShareConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance ShareConnectionExecArray) Exec(ctx context.Context) ([]ShareConnection, error) {
	var v []ShareConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type ShareConnection struct {
}

type PostPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance PostPreviousValuesExec) Exec(ctx context.Context) (*PostPreviousValues, error) {
	var v PostPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PostPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PostPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance PostPreviousValuesExecArray) Exec(ctx context.Context) ([]PostPreviousValues, error) {
	var v []PostPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PostPreviousValues struct {
	ID        string `json:"id"`
	Title     string `json:"title"`
	Published bool   `json:"published"`
}

type UserExec struct {
	exec *prisma.Exec
}

func (instance *UserExec) Thumbnail() *ThumbnailExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Thumbnail"},
		"thumbnail",
		[]string{"id", "name", "path"})

	return &ThumbnailExec{ret}
}

type PostsParamsExec struct {
	Where   *PostWhereInput
	OrderBy *PostOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *UserExec) Posts(params *PostsParamsExec) *PostExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"PostWhereInput", "PostOrderByInput", "Post"},
		"posts",
		[]string{"id", "title", "published"})

	return &PostExecArray{ret}
}

func (instance UserExec) Exec(ctx context.Context) (*User, error) {
	var v User
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserExecArray struct {
	exec *prisma.Exec
}

func (instance UserExecArray) Exec(ctx context.Context) ([]User, error) {
	var v []User
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type User struct {
	ID        string  `json:"id"`
	Email     *string `json:"email,omitempty"`
	Firstname string  `json:"firstname"`
	Lastname  string  `json:"lastname"`
}

type LinkEdgeExec struct {
	exec *prisma.Exec
}

func (instance *LinkEdgeExec) Node() *LinkExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Link"},
		"node",
		[]string{"id", "name", "desc", "url"})

	return &LinkExec{ret}
}

func (instance LinkEdgeExec) Exec(ctx context.Context) (*LinkEdge, error) {
	var v LinkEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance LinkEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type LinkEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance LinkEdgeExecArray) Exec(ctx context.Context) ([]LinkEdge, error) {
	var v []LinkEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type LinkEdge struct {
	Cursor string `json:"cursor"`
}

type ShareSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *ShareSubscriptionPayloadExec) Node() *ShareExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Share"},
		"node",
		[]string{"id"})

	return &ShareExec{ret}
}

func (instance *ShareSubscriptionPayloadExec) PreviousValues() *SharePreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "SharePreviousValues"},
		"previousValues",
		[]string{"id"})

	return &SharePreviousValuesExec{ret}
}

func (instance ShareSubscriptionPayloadExec) Exec(ctx context.Context) (*ShareSubscriptionPayload, error) {
	var v ShareSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ShareSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ShareSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance ShareSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]ShareSubscriptionPayload, error) {
	var v []ShareSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type ShareSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type UserSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *UserSubscriptionPayloadExec) Node() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"node",
		[]string{"id", "email", "firstname", "lastname"})

	return &UserExec{ret}
}

func (instance *UserSubscriptionPayloadExec) PreviousValues() *UserPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "UserPreviousValues"},
		"previousValues",
		[]string{"id", "email", "firstname", "lastname"})

	return &UserPreviousValuesExec{ret}
}

func (instance UserSubscriptionPayloadExec) Exec(ctx context.Context) (*UserSubscriptionPayload, error) {
	var v UserSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance UserSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]UserSubscriptionPayload, error) {
	var v []UserSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type UserSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type SharePreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance SharePreviousValuesExec) Exec(ctx context.Context) (*SharePreviousValues, error) {
	var v SharePreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance SharePreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type SharePreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance SharePreviousValuesExecArray) Exec(ctx context.Context) ([]SharePreviousValues, error) {
	var v []SharePreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type SharePreviousValues struct {
	ID string `json:"id"`
}

type ThumbnailExec struct {
	exec *prisma.Exec
}

func (instance ThumbnailExec) Exec(ctx context.Context) (*Thumbnail, error) {
	var v Thumbnail
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ThumbnailExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ThumbnailExecArray struct {
	exec *prisma.Exec
}

func (instance ThumbnailExecArray) Exec(ctx context.Context) ([]Thumbnail, error) {
	var v []Thumbnail
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Thumbnail struct {
	ID   string  `json:"id"`
	Name string  `json:"name"`
	Path *string `json:"path,omitempty"`
}

type PostEdgeExec struct {
	exec *prisma.Exec
}

func (instance *PostEdgeExec) Node() *PostExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Post"},
		"node",
		[]string{"id", "title", "published"})

	return &PostExec{ret}
}

func (instance PostEdgeExec) Exec(ctx context.Context) (*PostEdge, error) {
	var v PostEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PostEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PostEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance PostEdgeExecArray) Exec(ctx context.Context) ([]PostEdge, error) {
	var v []PostEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PostEdge struct {
	Cursor string `json:"cursor"`
}

type LinkExec struct {
	exec *prisma.Exec
}

func (instance *LinkExec) Thumbnail() *ThumbnailExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Thumbnail"},
		"thumbnail",
		[]string{"id", "name", "path"})

	return &ThumbnailExec{ret}
}

func (instance *LinkExec) Folio() *FolioExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Folio"},
		"folio",
		[]string{"id", "name", "desc"})

	return &FolioExec{ret}
}

func (instance LinkExec) Exec(ctx context.Context) (*Link, error) {
	var v Link
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance LinkExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type LinkExecArray struct {
	exec *prisma.Exec
}

func (instance LinkExecArray) Exec(ctx context.Context) ([]Link, error) {
	var v []Link
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Link struct {
	ID   string  `json:"id"`
	Name string  `json:"name"`
	Desc *string `json:"desc,omitempty"`
	Url  *string `json:"url,omitempty"`
}

type TagPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance TagPreviousValuesExec) Exec(ctx context.Context) (*TagPreviousValues, error) {
	var v TagPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TagPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TagPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance TagPreviousValuesExecArray) Exec(ctx context.Context) ([]TagPreviousValues, error) {
	var v []TagPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type TagPreviousValues struct {
	ID   string   `json:"id"`
	Kind *TagType `json:"kind,omitempty"`
	Name string   `json:"name"`
	Desc string   `json:"desc"`
}

type TagSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *TagSubscriptionPayloadExec) Node() *TagExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Tag"},
		"node",
		[]string{"id", "kind", "name", "desc"})

	return &TagExec{ret}
}

func (instance *TagSubscriptionPayloadExec) PreviousValues() *TagPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "TagPreviousValues"},
		"previousValues",
		[]string{"id", "kind", "name", "desc"})

	return &TagPreviousValuesExec{ret}
}

func (instance TagSubscriptionPayloadExec) Exec(ctx context.Context) (*TagSubscriptionPayload, error) {
	var v TagSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TagSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TagSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance TagSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]TagSubscriptionPayload, error) {
	var v []TagSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type TagSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type NoteExec struct {
	exec *prisma.Exec
}

func (instance *NoteExec) Thumbnail() *ThumbnailExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Thumbnail"},
		"thumbnail",
		[]string{"id", "name", "path"})

	return &ThumbnailExec{ret}
}

func (instance *NoteExec) Folio() *FolioExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Folio"},
		"folio",
		[]string{"id", "name", "desc"})

	return &FolioExec{ret}
}

func (instance NoteExec) Exec(ctx context.Context) (*Note, error) {
	var v Note
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance NoteExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type NoteExecArray struct {
	exec *prisma.Exec
}

func (instance NoteExecArray) Exec(ctx context.Context) ([]Note, error) {
	var v []Note
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Note struct {
	ID   string  `json:"id"`
	Name string  `json:"name"`
	Note *string `json:"note,omitempty"`
}

type NoteConnectionExec struct {
	exec *prisma.Exec
}

func (instance *NoteConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *NoteConnectionExec) Edges() *NoteEdgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "NoteEdge"},
		"edges",
		[]string{"cursor"})

	return &NoteEdgeExec{ret}
}

func (instance *NoteConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateNote"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return v, err
}

func (instance NoteConnectionExec) Exec(ctx context.Context) (*NoteConnection, error) {
	var v NoteConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance NoteConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type NoteConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance NoteConnectionExecArray) Exec(ctx context.Context) ([]NoteConnection, error) {
	var v []NoteConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type NoteConnection struct {
}

type ThumbnailPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance ThumbnailPreviousValuesExec) Exec(ctx context.Context) (*ThumbnailPreviousValues, error) {
	var v ThumbnailPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ThumbnailPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ThumbnailPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance ThumbnailPreviousValuesExecArray) Exec(ctx context.Context) ([]ThumbnailPreviousValues, error) {
	var v []ThumbnailPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type ThumbnailPreviousValues struct {
	ID   string  `json:"id"`
	Name string  `json:"name"`
	Path *string `json:"path,omitempty"`
}
