// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: folio.proto

/*
Package folio is a generated protocol buffer package.

It is generated from these files:
	folio.proto

It has these top-level messages:
	Account
	CreateAccountRequest
	CreateAccountResponse
	ReadAccountRequest
	ReadAccountResponse
	UpdateAccountRequest
	UpdateAccountResponse
	DeleteAccountRequest
	DeleteAccountsRequest
	DeleteAccountResponse
	ListAccountResponse
	ListSomethingResponse
	Something
	ListAccountRequest
	User
	CreateUserRequest
	CreateUserResponse
	ReadUserRequest
	ReadUserResponse
	UpdateUserRequest
	UpdateUserResponse
	DeleteUserRequest
	DeleteUsersRequest
	DeleteUserResponse
	ListUserResponse
	ListUserRequest
	Archive
	CreateArchiveRequest
	CreateArchiveResponse
	ReadArchiveRequest
	ReadArchiveResponse
	UpdateArchiveRequest
	UpdateArchiveResponse
	DeleteArchiveRequest
	DeleteArchivesRequest
	DeleteArchiveResponse
	ListArchiveResponse
	ListArchiveRequest
	Share
	CreateShareRequest
	CreateShareResponse
	ReadShareRequest
	ReadShareResponse
	UpdateShareRequest
	UpdateShareResponse
	DeleteShareRequest
	DeleteSharesRequest
	DeleteShareResponse
	ListShareResponse
	ListShareRequest
	Tag
	CreateTagRequest
	CreateTagResponse
	ReadTagRequest
	ReadTagResponse
	UpdateTagRequest
	UpdateTagResponse
	DeleteTagRequest
	DeleteTagsRequest
	DeleteTagResponse
	ListTagResponse
	ListTagRequest
	Folio
	CreateFolioRequest
	CreateFolioResponse
	ReadFolioRequest
	ReadFolioResponse
	UpdateFolioRequest
	UpdateFolioResponse
	DeleteFolioRequest
	DeleteFoliosRequest
	DeleteFolioResponse
	ListFolioResponse
	ListFolioRequest
	Asset
	CreateAssetRequest
	CreateAssetResponse
	ReadAssetRequest
	ReadAssetResponse
	UpdateAssetRequest
	UpdateAssetResponse
	DeleteAssetRequest
	DeleteAssetsRequest
	DeleteAssetResponse
	ListAssetResponse
	ListAssetRequest
	Note
	CreateNoteRequest
	CreateNoteResponse
	ReadNoteRequest
	ReadNoteResponse
	UpdateNoteRequest
	UpdateNoteResponse
	DeleteNoteRequest
	DeleteNotesRequest
	DeleteNoteResponse
	ListNoteResponse
	ListNoteRequest
*/
package folio

import context "context"
import errors "errors"
import strings "strings"

import field_mask1 "google.golang.org/genproto/protobuf/field_mask"
import gorm1 "github.com/jinzhu/gorm"
import gorm2 "github.com/infobloxopen/atlas-app-toolkit/gorm"

import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import _ "github.com/lyft/protoc-gen-validate/validate"
import _ "google.golang.org/genproto/protobuf/field_mask"
import _ "github.com/infobloxopen/atlas-app-toolkit/query"

// Reference imports to suppress errors if they are not otherwise used.
var _ = fmt.Errorf
var _ = math.Inf

type AccountORM struct {
	Archive   *ArchiveORM `gorm:"foreignkey:AccountId;association_foreignkey:Id"`
	ArchiveId *uint32
	Id        uint32
	Kind      string
	Name      string
	Nickname  string
	UUID      string
	UserId    *uint32
	Users     []*UserORM `gorm:"foreignkey:AccountId;association_foreignkey:Id"`
}

// TableName overrides the default tablename generated by GORM
func (AccountORM) TableName() string {
	return "accounts"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Account) ToORM(ctx context.Context) (AccountORM, error) {
	to := AccountORM{}
	var err error
	if prehook, ok := interface{}(m).(AccountWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.UUID = m.UUID
	to.Name = m.Name
	to.Nickname = m.Nickname
	to.Kind = m.Kind
	if m.Archive != nil {
		tempArchive, err := m.Archive.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Archive = &tempArchive
	}
	for _, v := range m.Users {
		if v != nil {
			if tempUsers, cErr := v.ToORM(ctx); cErr == nil {
				to.Users = append(to.Users, &tempUsers)
			} else {
				return to, cErr
			}
		} else {
			to.Users = append(to.Users, nil)
		}
	}
	if posthook, ok := interface{}(m).(AccountWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *AccountORM) ToPB(ctx context.Context) (Account, error) {
	to := Account{}
	var err error
	if prehook, ok := interface{}(m).(AccountWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.UUID = m.UUID
	to.Name = m.Name
	to.Nickname = m.Nickname
	to.Kind = m.Kind
	if m.Archive != nil {
		tempArchive, err := m.Archive.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Archive = &tempArchive
	}
	for _, v := range m.Users {
		if v != nil {
			if tempUsers, cErr := v.ToPB(ctx); cErr == nil {
				to.Users = append(to.Users, &tempUsers)
			} else {
				return to, cErr
			}
		} else {
			to.Users = append(to.Users, nil)
		}
	}
	if posthook, ok := interface{}(m).(AccountWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Account the arg will be the target, the caller the one being converted from

// AccountBeforeToORM called before default ToORM code
type AccountWithBeforeToORM interface {
	BeforeToORM(context.Context, *AccountORM) error
}

// AccountAfterToORM called after default ToORM code
type AccountWithAfterToORM interface {
	AfterToORM(context.Context, *AccountORM) error
}

// AccountBeforeToPB called before default ToPB code
type AccountWithBeforeToPB interface {
	BeforeToPB(context.Context, *Account) error
}

// AccountAfterToPB called after default ToPB code
type AccountWithAfterToPB interface {
	AfterToPB(context.Context, *Account) error
}

type SomethingORM struct {
	Field string
}

// TableName overrides the default tablename generated by GORM
func (SomethingORM) TableName() string {
	return "somethings"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Something) ToORM(ctx context.Context) (SomethingORM, error) {
	to := SomethingORM{}
	var err error
	if prehook, ok := interface{}(m).(SomethingWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Field = m.Field
	if posthook, ok := interface{}(m).(SomethingWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *SomethingORM) ToPB(ctx context.Context) (Something, error) {
	to := Something{}
	var err error
	if prehook, ok := interface{}(m).(SomethingWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Field = m.Field
	if posthook, ok := interface{}(m).(SomethingWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Something the arg will be the target, the caller the one being converted from

// SomethingBeforeToORM called before default ToORM code
type SomethingWithBeforeToORM interface {
	BeforeToORM(context.Context, *SomethingORM) error
}

// SomethingAfterToORM called after default ToORM code
type SomethingWithAfterToORM interface {
	AfterToORM(context.Context, *SomethingORM) error
}

// SomethingBeforeToPB called before default ToPB code
type SomethingWithBeforeToPB interface {
	BeforeToPB(context.Context, *Something) error
}

// SomethingAfterToPB called after default ToPB code
type SomethingWithAfterToPB interface {
	AfterToPB(context.Context, *Something) error
}

type UserORM struct {
	Account   *AccountORM `gorm:"foreignkey:UserId;association_foreignkey:Id"`
	AccountId *uint32
	ArchiveId *uint32
	Email     string
	Firstname string
	Id        uint32
	Lastname  string
}

// TableName overrides the default tablename generated by GORM
func (UserORM) TableName() string {
	return "users"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *User) ToORM(ctx context.Context) (UserORM, error) {
	to := UserORM{}
	var err error
	if prehook, ok := interface{}(m).(UserWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Email = m.Email
	to.Firstname = m.Firstname
	to.Lastname = m.Lastname
	if m.Account != nil {
		tempAccount, err := m.Account.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Account = &tempAccount
	}
	if posthook, ok := interface{}(m).(UserWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *UserORM) ToPB(ctx context.Context) (User, error) {
	to := User{}
	var err error
	if prehook, ok := interface{}(m).(UserWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Email = m.Email
	to.Firstname = m.Firstname
	to.Lastname = m.Lastname
	if m.Account != nil {
		tempAccount, err := m.Account.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Account = &tempAccount
	}
	if posthook, ok := interface{}(m).(UserWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type User the arg will be the target, the caller the one being converted from

// UserBeforeToORM called before default ToORM code
type UserWithBeforeToORM interface {
	BeforeToORM(context.Context, *UserORM) error
}

// UserAfterToORM called after default ToORM code
type UserWithAfterToORM interface {
	AfterToORM(context.Context, *UserORM) error
}

// UserBeforeToPB called before default ToPB code
type UserWithBeforeToPB interface {
	BeforeToPB(context.Context, *User) error
}

// UserAfterToPB called after default ToPB code
type UserWithAfterToPB interface {
	AfterToPB(context.Context, *User) error
}

type ArchiveORM struct {
	Account   *AccountORM `gorm:"foreignkey:ArchiveId;association_foreignkey:Id"`
	AccountId *uint32
	Desc      string
	FolioId   *uint32
	Folios    []*FolioORM `gorm:"foreignkey:ArchiveId;association_foreignkey:Id"`
	Id        uint32
	Name      string
	Owner     *UserORM `gorm:"foreignkey:ArchiveId;association_foreignkey:Id"`
	UUID      string
}

// TableName overrides the default tablename generated by GORM
func (ArchiveORM) TableName() string {
	return "archives"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Archive) ToORM(ctx context.Context) (ArchiveORM, error) {
	to := ArchiveORM{}
	var err error
	if prehook, ok := interface{}(m).(ArchiveWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.UUID = m.UUID
	to.Name = m.Name
	to.Desc = m.Desc
	for _, v := range m.Folios {
		if v != nil {
			if tempFolios, cErr := v.ToORM(ctx); cErr == nil {
				to.Folios = append(to.Folios, &tempFolios)
			} else {
				return to, cErr
			}
		} else {
			to.Folios = append(to.Folios, nil)
		}
	}
	if m.Account != nil {
		tempAccount, err := m.Account.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Account = &tempAccount
	}
	if m.Owner != nil {
		tempOwner, err := m.Owner.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Owner = &tempOwner
	}
	if posthook, ok := interface{}(m).(ArchiveWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ArchiveORM) ToPB(ctx context.Context) (Archive, error) {
	to := Archive{}
	var err error
	if prehook, ok := interface{}(m).(ArchiveWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.UUID = m.UUID
	to.Name = m.Name
	to.Desc = m.Desc
	for _, v := range m.Folios {
		if v != nil {
			if tempFolios, cErr := v.ToPB(ctx); cErr == nil {
				to.Folios = append(to.Folios, &tempFolios)
			} else {
				return to, cErr
			}
		} else {
			to.Folios = append(to.Folios, nil)
		}
	}
	if m.Account != nil {
		tempAccount, err := m.Account.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Account = &tempAccount
	}
	if m.Owner != nil {
		tempOwner, err := m.Owner.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Owner = &tempOwner
	}
	if posthook, ok := interface{}(m).(ArchiveWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Archive the arg will be the target, the caller the one being converted from

// ArchiveBeforeToORM called before default ToORM code
type ArchiveWithBeforeToORM interface {
	BeforeToORM(context.Context, *ArchiveORM) error
}

// ArchiveAfterToORM called after default ToORM code
type ArchiveWithAfterToORM interface {
	AfterToORM(context.Context, *ArchiveORM) error
}

// ArchiveBeforeToPB called before default ToPB code
type ArchiveWithBeforeToPB interface {
	BeforeToPB(context.Context, *Archive) error
}

// ArchiveAfterToPB called after default ToPB code
type ArchiveWithAfterToPB interface {
	AfterToPB(context.Context, *Archive) error
}

type ShareORM struct {
	Folios []*FolioORM `gorm:"foreignkey:Id;association_foreignkey:Id;many2many:share_folios;jointable_foreignkey:share_id;association_jointable_foreignkey:folio_id"`
	Friend *TagORM     `gorm:"foreignkey:ShareId;association_foreignkey:Id"`
	Id     uint32
}

// TableName overrides the default tablename generated by GORM
func (ShareORM) TableName() string {
	return "shares"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Share) ToORM(ctx context.Context) (ShareORM, error) {
	to := ShareORM{}
	var err error
	if prehook, ok := interface{}(m).(ShareWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.Friend != nil {
		tempFriend, err := m.Friend.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Friend = &tempFriend
	}
	for _, v := range m.Folios {
		if v != nil {
			if tempFolios, cErr := v.ToORM(ctx); cErr == nil {
				to.Folios = append(to.Folios, &tempFolios)
			} else {
				return to, cErr
			}
		} else {
			to.Folios = append(to.Folios, nil)
		}
	}
	if posthook, ok := interface{}(m).(ShareWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ShareORM) ToPB(ctx context.Context) (Share, error) {
	to := Share{}
	var err error
	if prehook, ok := interface{}(m).(ShareWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.Friend != nil {
		tempFriend, err := m.Friend.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Friend = &tempFriend
	}
	for _, v := range m.Folios {
		if v != nil {
			if tempFolios, cErr := v.ToPB(ctx); cErr == nil {
				to.Folios = append(to.Folios, &tempFolios)
			} else {
				return to, cErr
			}
		} else {
			to.Folios = append(to.Folios, nil)
		}
	}
	if posthook, ok := interface{}(m).(ShareWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Share the arg will be the target, the caller the one being converted from

// ShareBeforeToORM called before default ToORM code
type ShareWithBeforeToORM interface {
	BeforeToORM(context.Context, *ShareORM) error
}

// ShareAfterToORM called after default ToORM code
type ShareWithAfterToORM interface {
	AfterToORM(context.Context, *ShareORM) error
}

// ShareBeforeToPB called before default ToPB code
type ShareWithBeforeToPB interface {
	BeforeToPB(context.Context, *Share) error
}

// ShareAfterToPB called after default ToPB code
type ShareWithAfterToPB interface {
	AfterToPB(context.Context, *Share) error
}

type TagORM struct {
	Desc    string
	Folios  []*FolioORM `gorm:"foreignkey:Id;association_foreignkey:Id;many2many:tag_folios;jointable_foreignkey:tag_id;association_jointable_foreignkey:folio_id"`
	Id      uint32
	Kind    uint32
	Label   string
	ShareId *uint32
}

// TableName overrides the default tablename generated by GORM
func (TagORM) TableName() string {
	return "tags"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Tag) ToORM(ctx context.Context) (TagORM, error) {
	to := TagORM{}
	var err error
	if prehook, ok := interface{}(m).(TagWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Kind = m.Kind
	to.Label = m.Label
	to.Desc = m.Desc
	for _, v := range m.Folios {
		if v != nil {
			if tempFolios, cErr := v.ToORM(ctx); cErr == nil {
				to.Folios = append(to.Folios, &tempFolios)
			} else {
				return to, cErr
			}
		} else {
			to.Folios = append(to.Folios, nil)
		}
	}
	if posthook, ok := interface{}(m).(TagWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *TagORM) ToPB(ctx context.Context) (Tag, error) {
	to := Tag{}
	var err error
	if prehook, ok := interface{}(m).(TagWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Kind = m.Kind
	to.Label = m.Label
	to.Desc = m.Desc
	for _, v := range m.Folios {
		if v != nil {
			if tempFolios, cErr := v.ToPB(ctx); cErr == nil {
				to.Folios = append(to.Folios, &tempFolios)
			} else {
				return to, cErr
			}
		} else {
			to.Folios = append(to.Folios, nil)
		}
	}
	if posthook, ok := interface{}(m).(TagWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Tag the arg will be the target, the caller the one being converted from

// TagBeforeToORM called before default ToORM code
type TagWithBeforeToORM interface {
	BeforeToORM(context.Context, *TagORM) error
}

// TagAfterToORM called after default ToORM code
type TagWithAfterToORM interface {
	AfterToORM(context.Context, *TagORM) error
}

// TagBeforeToPB called before default ToPB code
type TagWithBeforeToPB interface {
	BeforeToPB(context.Context, *Tag) error
}

// TagAfterToPB called after default ToPB code
type TagWithAfterToPB interface {
	AfterToPB(context.Context, *Tag) error
}

type FolioORM struct {
	Archive   *ArchiveORM `gorm:"foreignkey:FolioId;association_foreignkey:Id"`
	ArchiveId *uint32
	AssetId   *uint32
	Assets    []*AssetORM `gorm:"foreignkey:FolioId;association_foreignkey:Id"`
	Desc      string
	Id        uint32
	Name      string
	NoteId    *uint32
	Notes     []*NoteORM  `gorm:"foreignkey:FolioId;association_foreignkey:Id"`
	Shares    []*ShareORM `gorm:"foreignkey:Id;association_foreignkey:Id;many2many:folio_shares;jointable_foreignkey:folio_id;association_jointable_foreignkey:share_id"`
	Tags      []*TagORM   `gorm:"foreignkey:Id;association_foreignkey:Id;many2many:folio_tags;jointable_foreignkey:folio_id;association_jointable_foreignkey:tag_id"`
	UUID      string
}

// TableName overrides the default tablename generated by GORM
func (FolioORM) TableName() string {
	return "folios"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Folio) ToORM(ctx context.Context) (FolioORM, error) {
	to := FolioORM{}
	var err error
	if prehook, ok := interface{}(m).(FolioWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.UUID = m.UUID
	to.Name = m.Name
	to.Desc = m.Desc
	if m.Archive != nil {
		tempArchive, err := m.Archive.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Archive = &tempArchive
	}
	for _, v := range m.Assets {
		if v != nil {
			if tempAssets, cErr := v.ToORM(ctx); cErr == nil {
				to.Assets = append(to.Assets, &tempAssets)
			} else {
				return to, cErr
			}
		} else {
			to.Assets = append(to.Assets, nil)
		}
	}
	for _, v := range m.Notes {
		if v != nil {
			if tempNotes, cErr := v.ToORM(ctx); cErr == nil {
				to.Notes = append(to.Notes, &tempNotes)
			} else {
				return to, cErr
			}
		} else {
			to.Notes = append(to.Notes, nil)
		}
	}
	for _, v := range m.Tags {
		if v != nil {
			if tempTags, cErr := v.ToORM(ctx); cErr == nil {
				to.Tags = append(to.Tags, &tempTags)
			} else {
				return to, cErr
			}
		} else {
			to.Tags = append(to.Tags, nil)
		}
	}
	for _, v := range m.Shares {
		if v != nil {
			if tempShares, cErr := v.ToORM(ctx); cErr == nil {
				to.Shares = append(to.Shares, &tempShares)
			} else {
				return to, cErr
			}
		} else {
			to.Shares = append(to.Shares, nil)
		}
	}
	if posthook, ok := interface{}(m).(FolioWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *FolioORM) ToPB(ctx context.Context) (Folio, error) {
	to := Folio{}
	var err error
	if prehook, ok := interface{}(m).(FolioWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.UUID = m.UUID
	to.Name = m.Name
	to.Desc = m.Desc
	if m.Archive != nil {
		tempArchive, err := m.Archive.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Archive = &tempArchive
	}
	for _, v := range m.Assets {
		if v != nil {
			if tempAssets, cErr := v.ToPB(ctx); cErr == nil {
				to.Assets = append(to.Assets, &tempAssets)
			} else {
				return to, cErr
			}
		} else {
			to.Assets = append(to.Assets, nil)
		}
	}
	for _, v := range m.Notes {
		if v != nil {
			if tempNotes, cErr := v.ToPB(ctx); cErr == nil {
				to.Notes = append(to.Notes, &tempNotes)
			} else {
				return to, cErr
			}
		} else {
			to.Notes = append(to.Notes, nil)
		}
	}
	for _, v := range m.Tags {
		if v != nil {
			if tempTags, cErr := v.ToPB(ctx); cErr == nil {
				to.Tags = append(to.Tags, &tempTags)
			} else {
				return to, cErr
			}
		} else {
			to.Tags = append(to.Tags, nil)
		}
	}
	for _, v := range m.Shares {
		if v != nil {
			if tempShares, cErr := v.ToPB(ctx); cErr == nil {
				to.Shares = append(to.Shares, &tempShares)
			} else {
				return to, cErr
			}
		} else {
			to.Shares = append(to.Shares, nil)
		}
	}
	if posthook, ok := interface{}(m).(FolioWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Folio the arg will be the target, the caller the one being converted from

// FolioBeforeToORM called before default ToORM code
type FolioWithBeforeToORM interface {
	BeforeToORM(context.Context, *FolioORM) error
}

// FolioAfterToORM called after default ToORM code
type FolioWithAfterToORM interface {
	AfterToORM(context.Context, *FolioORM) error
}

// FolioBeforeToPB called before default ToPB code
type FolioWithBeforeToPB interface {
	BeforeToPB(context.Context, *Folio) error
}

// FolioAfterToPB called after default ToPB code
type FolioWithAfterToPB interface {
	AfterToPB(context.Context, *Folio) error
}

type AssetORM struct {
	Asset   *AssetORM `gorm:"foreignkey:AssetId;association_foreignkey:Id"`
	AssetId *uint32
	Blob    []byte
	Folio   *FolioORM `gorm:"foreignkey:AssetId;association_foreignkey:Id"`
	FolioId *uint32
	Id      uint32
	Name    string
	Path    string
	UUID    string
}

// TableName overrides the default tablename generated by GORM
func (AssetORM) TableName() string {
	return "assets"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Asset) ToORM(ctx context.Context) (AssetORM, error) {
	to := AssetORM{}
	var err error
	if prehook, ok := interface{}(m).(AssetWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	if m.Folio != nil {
		tempFolio, err := m.Folio.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Folio = &tempFolio
	}
	to.UUID = m.UUID
	to.Path = m.Path
	if m.Asset != nil {
		tempAsset, err := m.Asset.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Asset = &tempAsset
	}
	to.Blob = m.Blob
	if posthook, ok := interface{}(m).(AssetWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *AssetORM) ToPB(ctx context.Context) (Asset, error) {
	to := Asset{}
	var err error
	if prehook, ok := interface{}(m).(AssetWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	if m.Folio != nil {
		tempFolio, err := m.Folio.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Folio = &tempFolio
	}
	to.UUID = m.UUID
	to.Path = m.Path
	if m.Asset != nil {
		tempAsset, err := m.Asset.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Asset = &tempAsset
	}
	to.Blob = m.Blob
	if posthook, ok := interface{}(m).(AssetWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Asset the arg will be the target, the caller the one being converted from

// AssetBeforeToORM called before default ToORM code
type AssetWithBeforeToORM interface {
	BeforeToORM(context.Context, *AssetORM) error
}

// AssetAfterToORM called after default ToORM code
type AssetWithAfterToORM interface {
	AfterToORM(context.Context, *AssetORM) error
}

// AssetBeforeToPB called before default ToPB code
type AssetWithBeforeToPB interface {
	BeforeToPB(context.Context, *Asset) error
}

// AssetAfterToPB called after default ToPB code
type AssetWithAfterToPB interface {
	AfterToPB(context.Context, *Asset) error
}

type NoteORM struct {
	Folio   *FolioORM `gorm:"foreignkey:NoteId;association_foreignkey:Id"`
	FolioId *uint32
	Id      uint32
	Name    string
	Note    string
}

// TableName overrides the default tablename generated by GORM
func (NoteORM) TableName() string {
	return "notes"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Note) ToORM(ctx context.Context) (NoteORM, error) {
	to := NoteORM{}
	var err error
	if prehook, ok := interface{}(m).(NoteWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.Note = m.Note
	if m.Folio != nil {
		tempFolio, err := m.Folio.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Folio = &tempFolio
	}
	if posthook, ok := interface{}(m).(NoteWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *NoteORM) ToPB(ctx context.Context) (Note, error) {
	to := Note{}
	var err error
	if prehook, ok := interface{}(m).(NoteWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.Note = m.Note
	if m.Folio != nil {
		tempFolio, err := m.Folio.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Folio = &tempFolio
	}
	if posthook, ok := interface{}(m).(NoteWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Note the arg will be the target, the caller the one being converted from

// NoteBeforeToORM called before default ToORM code
type NoteWithBeforeToORM interface {
	BeforeToORM(context.Context, *NoteORM) error
}

// NoteAfterToORM called after default ToORM code
type NoteWithAfterToORM interface {
	AfterToORM(context.Context, *NoteORM) error
}

// NoteBeforeToPB called before default ToPB code
type NoteWithBeforeToPB interface {
	BeforeToPB(context.Context, *Note) error
}

// NoteAfterToPB called after default ToPB code
type NoteWithAfterToPB interface {
	AfterToPB(context.Context, *Note) error
}

// DefaultCreateAccount executes a basic gorm create call
func DefaultCreateAccount(ctx context.Context, in *Account, db *gorm1.DB) (*Account, error) {
	if in == nil {
		return nil, errors.New("Nil argument to DefaultCreateAccount")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccountORMWithBeforeCreate); ok {
		if db, err = hook.BeforeCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccountORMWithAfterCreate); ok {
		if err = hook.AfterCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type AccountORMWithBeforeCreate interface {
	BeforeCreate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type AccountORMWithAfterCreate interface {
	AfterCreate(context.Context, *gorm1.DB) error
}

// DefaultReadAccount executes a basic gorm read call
func DefaultReadAccount(ctx context.Context, in *Account, db *gorm1.DB) (*Account, error) {
	if in == nil {
		return nil, errors.New("Nil argument to DefaultReadAccount")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.New("DefaultReadAccount requires a non-zero primary key")
	}
	if hook, ok := interface{}(&ormObj).(AccountORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &AccountORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccountORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := AccountORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(AccountORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type AccountORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type AccountORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type AccountORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteAccount(ctx context.Context, in *Account, db *gorm1.DB) error {
	if in == nil {
		return errors.New("Nil argument to DefaultDeleteAccount")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.New("A non-zero ID value is required for a delete call")
	}
	if hook, ok := interface{}(&ormObj).(AccountORMWithBeforeDelete); ok {
		if db, err = hook.BeforeDelete(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&AccountORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(AccountORMWithAfterDelete); ok {
		err = hook.AfterDelete(ctx, db)
	}
	return err
}

type AccountORMWithBeforeDelete interface {
	BeforeDelete(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type AccountORMWithAfterDelete interface {
	AfterDelete(context.Context, *gorm1.DB) error
}

func DefaultDeleteAccountSet(ctx context.Context, in []*Account, db *gorm1.DB) error {
	if in == nil {
		return errors.New("Nil argument to DefaultDeleteAccountSet")
	}
	var err error
	keys := []uint32{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.New("A non-zero ID value is required for a delete call")
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&AccountORM{})).(AccountORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&AccountORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&AccountORM{})).(AccountORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type AccountORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Account, *gorm1.DB) (*gorm1.DB, error)
}
type AccountORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Account, *gorm1.DB) error
}

// DefaultStrictUpdateAccount clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateAccount(ctx context.Context, in *Account, db *gorm1.DB) (*Account, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateAccount")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccountORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterArchive := ArchiveORM{}
	if ormObj.Id == 0 {
		return nil, errors.New("Can't do overwriting update with no Id value for AccountORM")
	}
	filterArchive.AccountId = new(uint32)
	*filterArchive.AccountId = ormObj.Id
	if err = db.Where(filterArchive).Delete(ArchiveORM{}).Error; err != nil {
		return nil, err
	}
	filterUsers := UserORM{}
	if ormObj.Id == 0 {
		return nil, errors.New("Can't do overwriting update with no Id value for AccountORM")
	}
	filterUsers.AccountId = new(uint32)
	*filterUsers.AccountId = ormObj.Id
	if err = db.Where(filterUsers).Delete(UserORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccountORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccountORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type AccountORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type AccountORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type AccountORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchAccount executes a basic gorm update call with patch behavior
func DefaultPatchAccount(ctx context.Context, in *Account, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Account, error) {
	if in == nil {
		return nil, errors.New("Nil argument to DefaultPatchAccount")
	}
	var pbObj Account
	var err error
	if hook, ok := interface{}(&pbObj).(AccountWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadAccount(ctx, &Account{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(AccountWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskAccount(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(AccountWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateAccount(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(AccountWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type AccountWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Account, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type AccountWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Account, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type AccountWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Account, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type AccountWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Account, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultApplyFieldMaskAccount patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskAccount(ctx context.Context, patchee *Account, patcher *Account, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Account, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.New("Patchee inputs to DefaultApplyFieldMaskAccount must be non-nil")
	}
	var err error
	var updatedArchive bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"UUID" {
			patchee.UUID = patcher.UUID
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Nickname" {
			patchee.Nickname = patcher.Nickname
			continue
		}
		if f == prefix+"Kind" {
			patchee.Kind = patcher.Kind
			continue
		}
		if strings.HasPrefix(f, prefix+"Archive.") && !updatedArchive {
			updatedArchive = true
			if patcher.Archive == nil {
				patchee.Archive = nil
				continue
			}
			if patchee.Archive == nil {
				patchee.Archive = &Archive{}
			}
			if o, err := DefaultApplyFieldMaskArchive(ctx, patchee.Archive, patcher.Archive, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Archive.", db); err != nil {
				return nil, err
			} else {
				patchee.Archive = o
			}
			continue
		}
		if f == prefix+"Archive" {
			updatedArchive = true
			patchee.Archive = patcher.Archive
			continue
		}
		if f == prefix+"Users" {
			patchee.Users = patcher.Users
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListAccount executes a gorm list call
func DefaultListAccount(ctx context.Context, db *gorm1.DB) ([]*Account, error) {
	in := Account{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccountORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &AccountORM{}, &Account{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccountORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []AccountORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccountORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Account{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type AccountORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type AccountORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type AccountORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]AccountORM) error
}

// DefaultCreateSomething executes a basic gorm create call
func DefaultCreateSomething(ctx context.Context, in *Something, db *gorm1.DB) (*Something, error) {
	if in == nil {
		return nil, errors.New("Nil argument to DefaultCreateSomething")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SomethingORMWithBeforeCreate); ok {
		if db, err = hook.BeforeCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SomethingORMWithAfterCreate); ok {
		if err = hook.AfterCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type SomethingORMWithBeforeCreate interface {
	BeforeCreate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type SomethingORMWithAfterCreate interface {
	AfterCreate(context.Context, *gorm1.DB) error
}

// DefaultApplyFieldMaskSomething patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskSomething(ctx context.Context, patchee *Something, patcher *Something, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Something, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.New("Patchee inputs to DefaultApplyFieldMaskSomething must be non-nil")
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Field" {
			patchee.Field = patcher.Field
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListSomething executes a gorm list call
func DefaultListSomething(ctx context.Context, db *gorm1.DB) ([]*Something, error) {
	in := Something{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SomethingORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &SomethingORM{}, &Something{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SomethingORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	ormResponse := []SomethingORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SomethingORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Something{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type SomethingORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type SomethingORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type SomethingORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]SomethingORM) error
}

// DefaultCreateUser executes a basic gorm create call
func DefaultCreateUser(ctx context.Context, in *User, db *gorm1.DB) (*User, error) {
	if in == nil {
		return nil, errors.New("Nil argument to DefaultCreateUser")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeCreate); ok {
		if db, err = hook.BeforeCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithAfterCreate); ok {
		if err = hook.AfterCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type UserORMWithBeforeCreate interface {
	BeforeCreate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type UserORMWithAfterCreate interface {
	AfterCreate(context.Context, *gorm1.DB) error
}

// DefaultReadUser executes a basic gorm read call
func DefaultReadUser(ctx context.Context, in *User, db *gorm1.DB) (*User, error) {
	if in == nil {
		return nil, errors.New("Nil argument to DefaultReadUser")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.New("DefaultReadUser requires a non-zero primary key")
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &UserORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := UserORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(UserORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type UserORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type UserORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type UserORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteUser(ctx context.Context, in *User, db *gorm1.DB) error {
	if in == nil {
		return errors.New("Nil argument to DefaultDeleteUser")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.New("A non-zero ID value is required for a delete call")
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeDelete); ok {
		if db, err = hook.BeforeDelete(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&UserORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithAfterDelete); ok {
		err = hook.AfterDelete(ctx, db)
	}
	return err
}

type UserORMWithBeforeDelete interface {
	BeforeDelete(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type UserORMWithAfterDelete interface {
	AfterDelete(context.Context, *gorm1.DB) error
}

func DefaultDeleteUserSet(ctx context.Context, in []*User, db *gorm1.DB) error {
	if in == nil {
		return errors.New("Nil argument to DefaultDeleteUserSet")
	}
	var err error
	keys := []uint32{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.New("A non-zero ID value is required for a delete call")
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&UserORM{})).(UserORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&UserORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&UserORM{})).(UserORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type UserORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*User, *gorm1.DB) (*gorm1.DB, error)
}
type UserORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*User, *gorm1.DB) error
}

// DefaultStrictUpdateUser clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateUser(ctx context.Context, in *User, db *gorm1.DB) (*User, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateUser")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterAccount := AccountORM{}
	if ormObj.Id == 0 {
		return nil, errors.New("Can't do overwriting update with no Id value for UserORM")
	}
	filterAccount.UserId = new(uint32)
	*filterAccount.UserId = ormObj.Id
	if err = db.Where(filterAccount).Delete(AccountORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type UserORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type UserORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type UserORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchUser executes a basic gorm update call with patch behavior
func DefaultPatchUser(ctx context.Context, in *User, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*User, error) {
	if in == nil {
		return nil, errors.New("Nil argument to DefaultPatchUser")
	}
	var pbObj User
	var err error
	if hook, ok := interface{}(&pbObj).(UserWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadUser(ctx, &User{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(UserWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskUser(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(UserWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateUser(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(UserWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type UserWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *User, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type UserWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *User, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type UserWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *User, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type UserWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *User, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultApplyFieldMaskUser patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskUser(ctx context.Context, patchee *User, patcher *User, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*User, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.New("Patchee inputs to DefaultApplyFieldMaskUser must be non-nil")
	}
	var err error
	var updatedAccount bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Email" {
			patchee.Email = patcher.Email
			continue
		}
		if f == prefix+"Firstname" {
			patchee.Firstname = patcher.Firstname
			continue
		}
		if f == prefix+"Lastname" {
			patchee.Lastname = patcher.Lastname
			continue
		}
		if strings.HasPrefix(f, prefix+"Account.") && !updatedAccount {
			updatedAccount = true
			if patcher.Account == nil {
				patchee.Account = nil
				continue
			}
			if patchee.Account == nil {
				patchee.Account = &Account{}
			}
			if o, err := DefaultApplyFieldMaskAccount(ctx, patchee.Account, patcher.Account, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Account.", db); err != nil {
				return nil, err
			} else {
				patchee.Account = o
			}
			continue
		}
		if f == prefix+"Account" {
			updatedAccount = true
			patchee.Account = patcher.Account
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListUser executes a gorm list call
func DefaultListUser(ctx context.Context, db *gorm1.DB) ([]*User, error) {
	in := User{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &UserORM{}, &User{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []UserORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*User{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type UserORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type UserORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type UserORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]UserORM) error
}

// DefaultCreateArchive executes a basic gorm create call
func DefaultCreateArchive(ctx context.Context, in *Archive, db *gorm1.DB) (*Archive, error) {
	if in == nil {
		return nil, errors.New("Nil argument to DefaultCreateArchive")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ArchiveORMWithBeforeCreate); ok {
		if db, err = hook.BeforeCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ArchiveORMWithAfterCreate); ok {
		if err = hook.AfterCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ArchiveORMWithBeforeCreate interface {
	BeforeCreate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ArchiveORMWithAfterCreate interface {
	AfterCreate(context.Context, *gorm1.DB) error
}

// DefaultReadArchive executes a basic gorm read call
func DefaultReadArchive(ctx context.Context, in *Archive, db *gorm1.DB) (*Archive, error) {
	if in == nil {
		return nil, errors.New("Nil argument to DefaultReadArchive")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.New("DefaultReadArchive requires a non-zero primary key")
	}
	if hook, ok := interface{}(&ormObj).(ArchiveORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &ArchiveORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ArchiveORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ArchiveORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ArchiveORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ArchiveORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ArchiveORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ArchiveORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteArchive(ctx context.Context, in *Archive, db *gorm1.DB) error {
	if in == nil {
		return errors.New("Nil argument to DefaultDeleteArchive")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.New("A non-zero ID value is required for a delete call")
	}
	if hook, ok := interface{}(&ormObj).(ArchiveORMWithBeforeDelete); ok {
		if db, err = hook.BeforeDelete(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ArchiveORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ArchiveORMWithAfterDelete); ok {
		err = hook.AfterDelete(ctx, db)
	}
	return err
}

type ArchiveORMWithBeforeDelete interface {
	BeforeDelete(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ArchiveORMWithAfterDelete interface {
	AfterDelete(context.Context, *gorm1.DB) error
}

func DefaultDeleteArchiveSet(ctx context.Context, in []*Archive, db *gorm1.DB) error {
	if in == nil {
		return errors.New("Nil argument to DefaultDeleteArchiveSet")
	}
	var err error
	keys := []uint32{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.New("A non-zero ID value is required for a delete call")
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ArchiveORM{})).(ArchiveORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&ArchiveORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ArchiveORM{})).(ArchiveORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ArchiveORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Archive, *gorm1.DB) (*gorm1.DB, error)
}
type ArchiveORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Archive, *gorm1.DB) error
}

// DefaultStrictUpdateArchive clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateArchive(ctx context.Context, in *Archive, db *gorm1.DB) (*Archive, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateArchive")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ArchiveORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterAccount := AccountORM{}
	if ormObj.Id == 0 {
		return nil, errors.New("Can't do overwriting update with no Id value for ArchiveORM")
	}
	filterAccount.ArchiveId = new(uint32)
	*filterAccount.ArchiveId = ormObj.Id
	if err = db.Where(filterAccount).Delete(AccountORM{}).Error; err != nil {
		return nil, err
	}
	filterFolios := FolioORM{}
	if ormObj.Id == 0 {
		return nil, errors.New("Can't do overwriting update with no Id value for ArchiveORM")
	}
	filterFolios.ArchiveId = new(uint32)
	*filterFolios.ArchiveId = ormObj.Id
	if err = db.Where(filterFolios).Delete(FolioORM{}).Error; err != nil {
		return nil, err
	}
	filterOwner := UserORM{}
	if ormObj.Id == 0 {
		return nil, errors.New("Can't do overwriting update with no Id value for ArchiveORM")
	}
	filterOwner.ArchiveId = new(uint32)
	*filterOwner.ArchiveId = ormObj.Id
	if err = db.Where(filterOwner).Delete(UserORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ArchiveORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ArchiveORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ArchiveORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ArchiveORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ArchiveORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchArchive executes a basic gorm update call with patch behavior
func DefaultPatchArchive(ctx context.Context, in *Archive, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Archive, error) {
	if in == nil {
		return nil, errors.New("Nil argument to DefaultPatchArchive")
	}
	var pbObj Archive
	var err error
	if hook, ok := interface{}(&pbObj).(ArchiveWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadArchive(ctx, &Archive{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ArchiveWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskArchive(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ArchiveWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateArchive(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ArchiveWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ArchiveWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Archive, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ArchiveWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Archive, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ArchiveWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Archive, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ArchiveWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Archive, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultApplyFieldMaskArchive patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskArchive(ctx context.Context, patchee *Archive, patcher *Archive, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Archive, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.New("Patchee inputs to DefaultApplyFieldMaskArchive must be non-nil")
	}
	var err error
	var updatedAccount bool
	var updatedOwner bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"UUID" {
			patchee.UUID = patcher.UUID
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Desc" {
			patchee.Desc = patcher.Desc
			continue
		}
		if f == prefix+"Folios" {
			patchee.Folios = patcher.Folios
			continue
		}
		if strings.HasPrefix(f, prefix+"Account.") && !updatedAccount {
			updatedAccount = true
			if patcher.Account == nil {
				patchee.Account = nil
				continue
			}
			if patchee.Account == nil {
				patchee.Account = &Account{}
			}
			if o, err := DefaultApplyFieldMaskAccount(ctx, patchee.Account, patcher.Account, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Account.", db); err != nil {
				return nil, err
			} else {
				patchee.Account = o
			}
			continue
		}
		if f == prefix+"Account" {
			updatedAccount = true
			patchee.Account = patcher.Account
			continue
		}
		if strings.HasPrefix(f, prefix+"Owner.") && !updatedOwner {
			updatedOwner = true
			if patcher.Owner == nil {
				patchee.Owner = nil
				continue
			}
			if patchee.Owner == nil {
				patchee.Owner = &User{}
			}
			if o, err := DefaultApplyFieldMaskUser(ctx, patchee.Owner, patcher.Owner, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Owner.", db); err != nil {
				return nil, err
			} else {
				patchee.Owner = o
			}
			continue
		}
		if f == prefix+"Owner" {
			updatedOwner = true
			patchee.Owner = patcher.Owner
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListArchive executes a gorm list call
func DefaultListArchive(ctx context.Context, db *gorm1.DB) ([]*Archive, error) {
	in := Archive{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ArchiveORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &ArchiveORM{}, &Archive{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ArchiveORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ArchiveORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ArchiveORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Archive{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ArchiveORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ArchiveORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ArchiveORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]ArchiveORM) error
}

// DefaultCreateShare executes a basic gorm create call
func DefaultCreateShare(ctx context.Context, in *Share, db *gorm1.DB) (*Share, error) {
	if in == nil {
		return nil, errors.New("Nil argument to DefaultCreateShare")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ShareORMWithBeforeCreate); ok {
		if db, err = hook.BeforeCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ShareORMWithAfterCreate); ok {
		if err = hook.AfterCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ShareORMWithBeforeCreate interface {
	BeforeCreate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ShareORMWithAfterCreate interface {
	AfterCreate(context.Context, *gorm1.DB) error
}

// DefaultReadShare executes a basic gorm read call
func DefaultReadShare(ctx context.Context, in *Share, db *gorm1.DB) (*Share, error) {
	if in == nil {
		return nil, errors.New("Nil argument to DefaultReadShare")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.New("DefaultReadShare requires a non-zero primary key")
	}
	if hook, ok := interface{}(&ormObj).(ShareORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &ShareORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ShareORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ShareORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ShareORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ShareORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ShareORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ShareORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteShare(ctx context.Context, in *Share, db *gorm1.DB) error {
	if in == nil {
		return errors.New("Nil argument to DefaultDeleteShare")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.New("A non-zero ID value is required for a delete call")
	}
	if hook, ok := interface{}(&ormObj).(ShareORMWithBeforeDelete); ok {
		if db, err = hook.BeforeDelete(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ShareORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ShareORMWithAfterDelete); ok {
		err = hook.AfterDelete(ctx, db)
	}
	return err
}

type ShareORMWithBeforeDelete interface {
	BeforeDelete(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ShareORMWithAfterDelete interface {
	AfterDelete(context.Context, *gorm1.DB) error
}

func DefaultDeleteShareSet(ctx context.Context, in []*Share, db *gorm1.DB) error {
	if in == nil {
		return errors.New("Nil argument to DefaultDeleteShareSet")
	}
	var err error
	keys := []uint32{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.New("A non-zero ID value is required for a delete call")
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ShareORM{})).(ShareORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&ShareORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ShareORM{})).(ShareORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ShareORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Share, *gorm1.DB) (*gorm1.DB, error)
}
type ShareORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Share, *gorm1.DB) error
}

// DefaultStrictUpdateShare clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateShare(ctx context.Context, in *Share, db *gorm1.DB) (*Share, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateShare")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ShareORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterFriend := TagORM{}
	if ormObj.Id == 0 {
		return nil, errors.New("Can't do overwriting update with no Id value for ShareORM")
	}
	filterFriend.ShareId = new(uint32)
	*filterFriend.ShareId = ormObj.Id
	if err = db.Where(filterFriend).Delete(TagORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ShareORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ShareORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ShareORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ShareORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ShareORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchShare executes a basic gorm update call with patch behavior
func DefaultPatchShare(ctx context.Context, in *Share, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Share, error) {
	if in == nil {
		return nil, errors.New("Nil argument to DefaultPatchShare")
	}
	var pbObj Share
	var err error
	if hook, ok := interface{}(&pbObj).(ShareWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadShare(ctx, &Share{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ShareWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskShare(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ShareWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateShare(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ShareWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ShareWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Share, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ShareWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Share, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ShareWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Share, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ShareWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Share, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultApplyFieldMaskShare patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskShare(ctx context.Context, patchee *Share, patcher *Share, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Share, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.New("Patchee inputs to DefaultApplyFieldMaskShare must be non-nil")
	}
	var err error
	var updatedFriend bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if strings.HasPrefix(f, prefix+"Friend.") && !updatedFriend {
			updatedFriend = true
			if patcher.Friend == nil {
				patchee.Friend = nil
				continue
			}
			if patchee.Friend == nil {
				patchee.Friend = &Tag{}
			}
			if o, err := DefaultApplyFieldMaskTag(ctx, patchee.Friend, patcher.Friend, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Friend.", db); err != nil {
				return nil, err
			} else {
				patchee.Friend = o
			}
			continue
		}
		if f == prefix+"Friend" {
			updatedFriend = true
			patchee.Friend = patcher.Friend
			continue
		}
		if f == prefix+"Folios" {
			patchee.Folios = patcher.Folios
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListShare executes a gorm list call
func DefaultListShare(ctx context.Context, db *gorm1.DB) ([]*Share, error) {
	in := Share{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ShareORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &ShareORM{}, &Share{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ShareORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ShareORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ShareORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Share{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ShareORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ShareORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ShareORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]ShareORM) error
}

// DefaultCreateTag executes a basic gorm create call
func DefaultCreateTag(ctx context.Context, in *Tag, db *gorm1.DB) (*Tag, error) {
	if in == nil {
		return nil, errors.New("Nil argument to DefaultCreateTag")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TagORMWithBeforeCreate); ok {
		if db, err = hook.BeforeCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TagORMWithAfterCreate); ok {
		if err = hook.AfterCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type TagORMWithBeforeCreate interface {
	BeforeCreate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type TagORMWithAfterCreate interface {
	AfterCreate(context.Context, *gorm1.DB) error
}

// DefaultReadTag executes a basic gorm read call
func DefaultReadTag(ctx context.Context, in *Tag, db *gorm1.DB) (*Tag, error) {
	if in == nil {
		return nil, errors.New("Nil argument to DefaultReadTag")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.New("DefaultReadTag requires a non-zero primary key")
	}
	if hook, ok := interface{}(&ormObj).(TagORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &TagORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TagORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := TagORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(TagORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type TagORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type TagORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type TagORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteTag(ctx context.Context, in *Tag, db *gorm1.DB) error {
	if in == nil {
		return errors.New("Nil argument to DefaultDeleteTag")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.New("A non-zero ID value is required for a delete call")
	}
	if hook, ok := interface{}(&ormObj).(TagORMWithBeforeDelete); ok {
		if db, err = hook.BeforeDelete(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&TagORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(TagORMWithAfterDelete); ok {
		err = hook.AfterDelete(ctx, db)
	}
	return err
}

type TagORMWithBeforeDelete interface {
	BeforeDelete(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type TagORMWithAfterDelete interface {
	AfterDelete(context.Context, *gorm1.DB) error
}

func DefaultDeleteTagSet(ctx context.Context, in []*Tag, db *gorm1.DB) error {
	if in == nil {
		return errors.New("Nil argument to DefaultDeleteTagSet")
	}
	var err error
	keys := []uint32{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.New("A non-zero ID value is required for a delete call")
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&TagORM{})).(TagORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&TagORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&TagORM{})).(TagORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type TagORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Tag, *gorm1.DB) (*gorm1.DB, error)
}
type TagORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Tag, *gorm1.DB) error
}

// DefaultStrictUpdateTag clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateTag(ctx context.Context, in *Tag, db *gorm1.DB) (*Tag, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateTag")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TagORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(TagORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TagORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type TagORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type TagORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type TagORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchTag executes a basic gorm update call with patch behavior
func DefaultPatchTag(ctx context.Context, in *Tag, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Tag, error) {
	if in == nil {
		return nil, errors.New("Nil argument to DefaultPatchTag")
	}
	var pbObj Tag
	var err error
	if hook, ok := interface{}(&pbObj).(TagWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadTag(ctx, &Tag{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(TagWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskTag(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(TagWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateTag(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(TagWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type TagWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Tag, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type TagWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Tag, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type TagWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Tag, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type TagWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Tag, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultApplyFieldMaskTag patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskTag(ctx context.Context, patchee *Tag, patcher *Tag, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Tag, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.New("Patchee inputs to DefaultApplyFieldMaskTag must be non-nil")
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Kind" {
			patchee.Kind = patcher.Kind
			continue
		}
		if f == prefix+"Label" {
			patchee.Label = patcher.Label
			continue
		}
		if f == prefix+"Desc" {
			patchee.Desc = patcher.Desc
			continue
		}
		if f == prefix+"Folios" {
			patchee.Folios = patcher.Folios
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListTag executes a gorm list call
func DefaultListTag(ctx context.Context, db *gorm1.DB) ([]*Tag, error) {
	in := Tag{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TagORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &TagORM{}, &Tag{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TagORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []TagORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TagORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Tag{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type TagORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type TagORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type TagORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]TagORM) error
}

// DefaultCreateFolio executes a basic gorm create call
func DefaultCreateFolio(ctx context.Context, in *Folio, db *gorm1.DB) (*Folio, error) {
	if in == nil {
		return nil, errors.New("Nil argument to DefaultCreateFolio")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FolioORMWithBeforeCreate); ok {
		if db, err = hook.BeforeCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FolioORMWithAfterCreate); ok {
		if err = hook.AfterCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type FolioORMWithBeforeCreate interface {
	BeforeCreate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FolioORMWithAfterCreate interface {
	AfterCreate(context.Context, *gorm1.DB) error
}

// DefaultReadFolio executes a basic gorm read call
func DefaultReadFolio(ctx context.Context, in *Folio, db *gorm1.DB) (*Folio, error) {
	if in == nil {
		return nil, errors.New("Nil argument to DefaultReadFolio")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.New("DefaultReadFolio requires a non-zero primary key")
	}
	if hook, ok := interface{}(&ormObj).(FolioORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &FolioORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FolioORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := FolioORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(FolioORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type FolioORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FolioORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FolioORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteFolio(ctx context.Context, in *Folio, db *gorm1.DB) error {
	if in == nil {
		return errors.New("Nil argument to DefaultDeleteFolio")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.New("A non-zero ID value is required for a delete call")
	}
	if hook, ok := interface{}(&ormObj).(FolioORMWithBeforeDelete); ok {
		if db, err = hook.BeforeDelete(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&FolioORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(FolioORMWithAfterDelete); ok {
		err = hook.AfterDelete(ctx, db)
	}
	return err
}

type FolioORMWithBeforeDelete interface {
	BeforeDelete(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FolioORMWithAfterDelete interface {
	AfterDelete(context.Context, *gorm1.DB) error
}

func DefaultDeleteFolioSet(ctx context.Context, in []*Folio, db *gorm1.DB) error {
	if in == nil {
		return errors.New("Nil argument to DefaultDeleteFolioSet")
	}
	var err error
	keys := []uint32{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.New("A non-zero ID value is required for a delete call")
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&FolioORM{})).(FolioORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&FolioORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&FolioORM{})).(FolioORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type FolioORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Folio, *gorm1.DB) (*gorm1.DB, error)
}
type FolioORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Folio, *gorm1.DB) error
}

// DefaultStrictUpdateFolio clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateFolio(ctx context.Context, in *Folio, db *gorm1.DB) (*Folio, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateFolio")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FolioORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterArchive := ArchiveORM{}
	if ormObj.Id == 0 {
		return nil, errors.New("Can't do overwriting update with no Id value for FolioORM")
	}
	filterArchive.FolioId = new(uint32)
	*filterArchive.FolioId = ormObj.Id
	if err = db.Where(filterArchive).Delete(ArchiveORM{}).Error; err != nil {
		return nil, err
	}
	filterAssets := AssetORM{}
	if ormObj.Id == 0 {
		return nil, errors.New("Can't do overwriting update with no Id value for FolioORM")
	}
	filterAssets.FolioId = new(uint32)
	*filterAssets.FolioId = ormObj.Id
	if err = db.Where(filterAssets).Delete(AssetORM{}).Error; err != nil {
		return nil, err
	}
	filterNotes := NoteORM{}
	if ormObj.Id == 0 {
		return nil, errors.New("Can't do overwriting update with no Id value for FolioORM")
	}
	filterNotes.FolioId = new(uint32)
	*filterNotes.FolioId = ormObj.Id
	if err = db.Where(filterNotes).Delete(NoteORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FolioORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FolioORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type FolioORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FolioORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FolioORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchFolio executes a basic gorm update call with patch behavior
func DefaultPatchFolio(ctx context.Context, in *Folio, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Folio, error) {
	if in == nil {
		return nil, errors.New("Nil argument to DefaultPatchFolio")
	}
	var pbObj Folio
	var err error
	if hook, ok := interface{}(&pbObj).(FolioWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadFolio(ctx, &Folio{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(FolioWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskFolio(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(FolioWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateFolio(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(FolioWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type FolioWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Folio, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type FolioWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Folio, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type FolioWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Folio, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type FolioWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Folio, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultApplyFieldMaskFolio patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskFolio(ctx context.Context, patchee *Folio, patcher *Folio, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Folio, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.New("Patchee inputs to DefaultApplyFieldMaskFolio must be non-nil")
	}
	var err error
	var updatedArchive bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"UUID" {
			patchee.UUID = patcher.UUID
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Desc" {
			patchee.Desc = patcher.Desc
			continue
		}
		if strings.HasPrefix(f, prefix+"Archive.") && !updatedArchive {
			updatedArchive = true
			if patcher.Archive == nil {
				patchee.Archive = nil
				continue
			}
			if patchee.Archive == nil {
				patchee.Archive = &Archive{}
			}
			if o, err := DefaultApplyFieldMaskArchive(ctx, patchee.Archive, patcher.Archive, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Archive.", db); err != nil {
				return nil, err
			} else {
				patchee.Archive = o
			}
			continue
		}
		if f == prefix+"Archive" {
			updatedArchive = true
			patchee.Archive = patcher.Archive
			continue
		}
		if f == prefix+"Assets" {
			patchee.Assets = patcher.Assets
			continue
		}
		if f == prefix+"Notes" {
			patchee.Notes = patcher.Notes
			continue
		}
		if f == prefix+"Tags" {
			patchee.Tags = patcher.Tags
			continue
		}
		if f == prefix+"Shares" {
			patchee.Shares = patcher.Shares
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListFolio executes a gorm list call
func DefaultListFolio(ctx context.Context, db *gorm1.DB) ([]*Folio, error) {
	in := Folio{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FolioORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &FolioORM{}, &Folio{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FolioORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []FolioORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FolioORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Folio{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type FolioORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FolioORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FolioORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]FolioORM) error
}

// DefaultCreateAsset executes a basic gorm create call
func DefaultCreateAsset(ctx context.Context, in *Asset, db *gorm1.DB) (*Asset, error) {
	if in == nil {
		return nil, errors.New("Nil argument to DefaultCreateAsset")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AssetORMWithBeforeCreate); ok {
		if db, err = hook.BeforeCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AssetORMWithAfterCreate); ok {
		if err = hook.AfterCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type AssetORMWithBeforeCreate interface {
	BeforeCreate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type AssetORMWithAfterCreate interface {
	AfterCreate(context.Context, *gorm1.DB) error
}

// DefaultReadAsset executes a basic gorm read call
func DefaultReadAsset(ctx context.Context, in *Asset, db *gorm1.DB) (*Asset, error) {
	if in == nil {
		return nil, errors.New("Nil argument to DefaultReadAsset")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.New("DefaultReadAsset requires a non-zero primary key")
	}
	if hook, ok := interface{}(&ormObj).(AssetORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &AssetORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AssetORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := AssetORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(AssetORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type AssetORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type AssetORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type AssetORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteAsset(ctx context.Context, in *Asset, db *gorm1.DB) error {
	if in == nil {
		return errors.New("Nil argument to DefaultDeleteAsset")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.New("A non-zero ID value is required for a delete call")
	}
	if hook, ok := interface{}(&ormObj).(AssetORMWithBeforeDelete); ok {
		if db, err = hook.BeforeDelete(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&AssetORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(AssetORMWithAfterDelete); ok {
		err = hook.AfterDelete(ctx, db)
	}
	return err
}

type AssetORMWithBeforeDelete interface {
	BeforeDelete(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type AssetORMWithAfterDelete interface {
	AfterDelete(context.Context, *gorm1.DB) error
}

func DefaultDeleteAssetSet(ctx context.Context, in []*Asset, db *gorm1.DB) error {
	if in == nil {
		return errors.New("Nil argument to DefaultDeleteAssetSet")
	}
	var err error
	keys := []uint32{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.New("A non-zero ID value is required for a delete call")
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&AssetORM{})).(AssetORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&AssetORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&AssetORM{})).(AssetORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type AssetORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Asset, *gorm1.DB) (*gorm1.DB, error)
}
type AssetORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Asset, *gorm1.DB) error
}

// DefaultStrictUpdateAsset clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateAsset(ctx context.Context, in *Asset, db *gorm1.DB) (*Asset, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateAsset")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AssetORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterAsset := AssetORM{}
	if ormObj.Id == 0 {
		return nil, errors.New("Can't do overwriting update with no Id value for AssetORM")
	}
	filterAsset.AssetId = new(uint32)
	*filterAsset.AssetId = ormObj.Id
	if err = db.Where(filterAsset).Delete(AssetORM{}).Error; err != nil {
		return nil, err
	}
	filterFolio := FolioORM{}
	if ormObj.Id == 0 {
		return nil, errors.New("Can't do overwriting update with no Id value for AssetORM")
	}
	filterFolio.AssetId = new(uint32)
	*filterFolio.AssetId = ormObj.Id
	if err = db.Where(filterFolio).Delete(FolioORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AssetORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AssetORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type AssetORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type AssetORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type AssetORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchAsset executes a basic gorm update call with patch behavior
func DefaultPatchAsset(ctx context.Context, in *Asset, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Asset, error) {
	if in == nil {
		return nil, errors.New("Nil argument to DefaultPatchAsset")
	}
	var pbObj Asset
	var err error
	if hook, ok := interface{}(&pbObj).(AssetWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadAsset(ctx, &Asset{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(AssetWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskAsset(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(AssetWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateAsset(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(AssetWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type AssetWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Asset, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type AssetWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Asset, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type AssetWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Asset, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type AssetWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Asset, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultApplyFieldMaskAsset patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskAsset(ctx context.Context, patchee *Asset, patcher *Asset, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Asset, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.New("Patchee inputs to DefaultApplyFieldMaskAsset must be non-nil")
	}
	var err error
	var updatedFolio bool
	var updatedAsset bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if strings.HasPrefix(f, prefix+"Folio.") && !updatedFolio {
			updatedFolio = true
			if patcher.Folio == nil {
				patchee.Folio = nil
				continue
			}
			if patchee.Folio == nil {
				patchee.Folio = &Folio{}
			}
			if o, err := DefaultApplyFieldMaskFolio(ctx, patchee.Folio, patcher.Folio, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Folio.", db); err != nil {
				return nil, err
			} else {
				patchee.Folio = o
			}
			continue
		}
		if f == prefix+"Folio" {
			updatedFolio = true
			patchee.Folio = patcher.Folio
			continue
		}
		if f == prefix+"UUID" {
			patchee.UUID = patcher.UUID
			continue
		}
		if f == prefix+"Path" {
			patchee.Path = patcher.Path
			continue
		}
		if strings.HasPrefix(f, prefix+"Asset.") && !updatedAsset {
			updatedAsset = true
			if patcher.Asset == nil {
				patchee.Asset = nil
				continue
			}
			if patchee.Asset == nil {
				patchee.Asset = &Asset{}
			}
			if o, err := DefaultApplyFieldMaskAsset(ctx, patchee.Asset, patcher.Asset, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Asset.", db); err != nil {
				return nil, err
			} else {
				patchee.Asset = o
			}
			continue
		}
		if f == prefix+"Asset" {
			updatedAsset = true
			patchee.Asset = patcher.Asset
			continue
		}
		if f == prefix+"Blob" {
			patchee.Blob = patcher.Blob
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListAsset executes a gorm list call
func DefaultListAsset(ctx context.Context, db *gorm1.DB) ([]*Asset, error) {
	in := Asset{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AssetORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &AssetORM{}, &Asset{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AssetORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []AssetORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AssetORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Asset{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type AssetORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type AssetORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type AssetORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]AssetORM) error
}

// DefaultCreateNote executes a basic gorm create call
func DefaultCreateNote(ctx context.Context, in *Note, db *gorm1.DB) (*Note, error) {
	if in == nil {
		return nil, errors.New("Nil argument to DefaultCreateNote")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NoteORMWithBeforeCreate); ok {
		if db, err = hook.BeforeCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NoteORMWithAfterCreate); ok {
		if err = hook.AfterCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type NoteORMWithBeforeCreate interface {
	BeforeCreate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type NoteORMWithAfterCreate interface {
	AfterCreate(context.Context, *gorm1.DB) error
}

// DefaultReadNote executes a basic gorm read call
func DefaultReadNote(ctx context.Context, in *Note, db *gorm1.DB) (*Note, error) {
	if in == nil {
		return nil, errors.New("Nil argument to DefaultReadNote")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.New("DefaultReadNote requires a non-zero primary key")
	}
	if hook, ok := interface{}(&ormObj).(NoteORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &NoteORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NoteORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := NoteORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(NoteORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type NoteORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type NoteORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type NoteORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteNote(ctx context.Context, in *Note, db *gorm1.DB) error {
	if in == nil {
		return errors.New("Nil argument to DefaultDeleteNote")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.New("A non-zero ID value is required for a delete call")
	}
	if hook, ok := interface{}(&ormObj).(NoteORMWithBeforeDelete); ok {
		if db, err = hook.BeforeDelete(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&NoteORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(NoteORMWithAfterDelete); ok {
		err = hook.AfterDelete(ctx, db)
	}
	return err
}

type NoteORMWithBeforeDelete interface {
	BeforeDelete(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type NoteORMWithAfterDelete interface {
	AfterDelete(context.Context, *gorm1.DB) error
}

func DefaultDeleteNoteSet(ctx context.Context, in []*Note, db *gorm1.DB) error {
	if in == nil {
		return errors.New("Nil argument to DefaultDeleteNoteSet")
	}
	var err error
	keys := []uint32{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.New("A non-zero ID value is required for a delete call")
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&NoteORM{})).(NoteORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&NoteORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&NoteORM{})).(NoteORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type NoteORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Note, *gorm1.DB) (*gorm1.DB, error)
}
type NoteORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Note, *gorm1.DB) error
}

// DefaultStrictUpdateNote clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateNote(ctx context.Context, in *Note, db *gorm1.DB) (*Note, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateNote")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NoteORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterFolio := FolioORM{}
	if ormObj.Id == 0 {
		return nil, errors.New("Can't do overwriting update with no Id value for NoteORM")
	}
	filterFolio.NoteId = new(uint32)
	*filterFolio.NoteId = ormObj.Id
	if err = db.Where(filterFolio).Delete(FolioORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NoteORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NoteORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type NoteORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type NoteORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type NoteORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchNote executes a basic gorm update call with patch behavior
func DefaultPatchNote(ctx context.Context, in *Note, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Note, error) {
	if in == nil {
		return nil, errors.New("Nil argument to DefaultPatchNote")
	}
	var pbObj Note
	var err error
	if hook, ok := interface{}(&pbObj).(NoteWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadNote(ctx, &Note{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(NoteWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskNote(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(NoteWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateNote(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(NoteWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type NoteWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Note, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type NoteWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Note, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type NoteWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Note, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type NoteWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Note, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultApplyFieldMaskNote patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskNote(ctx context.Context, patchee *Note, patcher *Note, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Note, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.New("Patchee inputs to DefaultApplyFieldMaskNote must be non-nil")
	}
	var err error
	var updatedFolio bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Note" {
			patchee.Note = patcher.Note
			continue
		}
		if strings.HasPrefix(f, prefix+"Folio.") && !updatedFolio {
			updatedFolio = true
			if patcher.Folio == nil {
				patchee.Folio = nil
				continue
			}
			if patchee.Folio == nil {
				patchee.Folio = &Folio{}
			}
			if o, err := DefaultApplyFieldMaskFolio(ctx, patchee.Folio, patcher.Folio, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Folio.", db); err != nil {
				return nil, err
			} else {
				patchee.Folio = o
			}
			continue
		}
		if f == prefix+"Folio" {
			updatedFolio = true
			patchee.Folio = patcher.Folio
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListNote executes a gorm list call
func DefaultListNote(ctx context.Context, db *gorm1.DB) ([]*Note, error) {
	in := Note{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NoteORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &NoteORM{}, &Note{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NoteORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []NoteORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NoteORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Note{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type NoteORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type NoteORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type NoteORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]NoteORM) error
}
type FolioServiceDefaultServer struct {
	DB *gorm1.DB
}

// CreateUser ...
func (m *FolioServiceDefaultServer) CreateUser(ctx context.Context, in *CreateUserRequest) (*CreateUserResponse, error) {
	return &CreateUserResponse{}, nil
}

// ReadUser ...
func (m *FolioServiceDefaultServer) ReadUser(ctx context.Context, in *ReadUserRequest) (*ReadUserResponse, error) {
	return &ReadUserResponse{}, nil
}

// UpdateUser ...
func (m *FolioServiceDefaultServer) UpdateUser(ctx context.Context, in *UpdateUserRequest) (*UpdateUserResponse, error) {
	return &UpdateUserResponse{}, nil
}

// ListUser ...
func (m *FolioServiceDefaultServer) ListUser(ctx context.Context, in *ListUserRequest) (*ListUserResponse, error) {
	return &ListUserResponse{}, nil
}

// DeleteUser ...
func (m *FolioServiceDefaultServer) DeleteUser(ctx context.Context, in *DeleteUserRequest) (*DeleteUserResponse, error) {
	return &DeleteUserResponse{}, nil
}

// CreateAccount ...
func (m *FolioServiceDefaultServer) CreateAccount(ctx context.Context, in *CreateAccountRequest) (*CreateAccountResponse, error) {
	return &CreateAccountResponse{}, nil
}

// ReadAccount ...
func (m *FolioServiceDefaultServer) ReadAccount(ctx context.Context, in *ReadAccountRequest) (*ReadAccountResponse, error) {
	return &ReadAccountResponse{}, nil
}

// UpdateAccount ...
func (m *FolioServiceDefaultServer) UpdateAccount(ctx context.Context, in *UpdateAccountRequest) (*UpdateAccountResponse, error) {
	return &UpdateAccountResponse{}, nil
}

// ListAccount ...
func (m *FolioServiceDefaultServer) ListAccount(ctx context.Context, in *ListAccountRequest) (*ListAccountResponse, error) {
	return &ListAccountResponse{}, nil
}

// DeleteAccount ...
func (m *FolioServiceDefaultServer) DeleteAccount(ctx context.Context, in *DeleteAccountRequest) (*DeleteAccountResponse, error) {
	return &DeleteAccountResponse{}, nil
}

// CreateArchive ...
func (m *FolioServiceDefaultServer) CreateArchive(ctx context.Context, in *CreateArchiveRequest) (*CreateArchiveResponse, error) {
	return &CreateArchiveResponse{}, nil
}

// ReadArchive ...
func (m *FolioServiceDefaultServer) ReadArchive(ctx context.Context, in *ReadArchiveRequest) (*ReadArchiveResponse, error) {
	return &ReadArchiveResponse{}, nil
}

// UpdateArchive ...
func (m *FolioServiceDefaultServer) UpdateArchive(ctx context.Context, in *UpdateArchiveRequest) (*UpdateArchiveResponse, error) {
	return &UpdateArchiveResponse{}, nil
}

// ListArchive ...
func (m *FolioServiceDefaultServer) ListArchive(ctx context.Context, in *ListArchiveRequest) (*ListArchiveResponse, error) {
	return &ListArchiveResponse{}, nil
}

// DeleteArchive ...
func (m *FolioServiceDefaultServer) DeleteArchive(ctx context.Context, in *DeleteArchiveRequest) (*DeleteArchiveResponse, error) {
	return &DeleteArchiveResponse{}, nil
}

// CreateFolio ...
func (m *FolioServiceDefaultServer) CreateFolio(ctx context.Context, in *CreateFolioRequest) (*CreateFolioResponse, error) {
	return &CreateFolioResponse{}, nil
}

// ReadFolio ...
func (m *FolioServiceDefaultServer) ReadFolio(ctx context.Context, in *ReadFolioRequest) (*ReadFolioResponse, error) {
	return &ReadFolioResponse{}, nil
}

// UpdateFolio ...
func (m *FolioServiceDefaultServer) UpdateFolio(ctx context.Context, in *UpdateFolioRequest) (*UpdateFolioResponse, error) {
	return &UpdateFolioResponse{}, nil
}

// ListFolio ...
func (m *FolioServiceDefaultServer) ListFolio(ctx context.Context, in *ListFolioRequest) (*ListFolioResponse, error) {
	return &ListFolioResponse{}, nil
}

// DeleteFolio ...
func (m *FolioServiceDefaultServer) DeleteFolio(ctx context.Context, in *DeleteFolioRequest) (*DeleteFolioResponse, error) {
	return &DeleteFolioResponse{}, nil
}

// CreateTag ...
func (m *FolioServiceDefaultServer) CreateTag(ctx context.Context, in *CreateTagRequest) (*CreateTagResponse, error) {
	return &CreateTagResponse{}, nil
}

// ReadTag ...
func (m *FolioServiceDefaultServer) ReadTag(ctx context.Context, in *ReadTagRequest) (*ReadTagResponse, error) {
	return &ReadTagResponse{}, nil
}

// UpdateTag ...
func (m *FolioServiceDefaultServer) UpdateTag(ctx context.Context, in *UpdateTagRequest) (*UpdateTagResponse, error) {
	return &UpdateTagResponse{}, nil
}

// ListTag ...
func (m *FolioServiceDefaultServer) ListTag(ctx context.Context, in *ListTagRequest) (*ListTagResponse, error) {
	return &ListTagResponse{}, nil
}

// DeleteTag ...
func (m *FolioServiceDefaultServer) DeleteTag(ctx context.Context, in *DeleteTagRequest) (*DeleteTagResponse, error) {
	return &DeleteTagResponse{}, nil
}

// CreateNote ...
func (m *FolioServiceDefaultServer) CreateNote(ctx context.Context, in *CreateNoteRequest) (*CreateNoteResponse, error) {
	return &CreateNoteResponse{}, nil
}

// ReadNote ...
func (m *FolioServiceDefaultServer) ReadNote(ctx context.Context, in *ReadNoteRequest) (*ReadNoteResponse, error) {
	return &ReadNoteResponse{}, nil
}

// UpdateNote ...
func (m *FolioServiceDefaultServer) UpdateNote(ctx context.Context, in *UpdateNoteRequest) (*UpdateNoteResponse, error) {
	return &UpdateNoteResponse{}, nil
}

// ListNote ...
func (m *FolioServiceDefaultServer) ListNote(ctx context.Context, in *ListNoteRequest) (*ListNoteResponse, error) {
	return &ListNoteResponse{}, nil
}

// DeleteNote ...
func (m *FolioServiceDefaultServer) DeleteNote(ctx context.Context, in *DeleteNoteRequest) (*DeleteNoteResponse, error) {
	return &DeleteNoteResponse{}, nil
}

type FolioTxnDefaultServer struct {
}

// CreateAccount ...
func (m *FolioTxnDefaultServer) CreateAccount(ctx context.Context, in *CreateAccountRequest) (*CreateAccountResponse, error) {
	return &CreateAccountResponse{}, nil
}

// ReadAccount ...
func (m *FolioTxnDefaultServer) ReadAccount(ctx context.Context, in *ReadAccountRequest) (*ReadAccountResponse, error) {
	return &ReadAccountResponse{}, nil
}

// UpdateAccount ...
func (m *FolioTxnDefaultServer) UpdateAccount(ctx context.Context, in *UpdateAccountRequest) (*UpdateAccountResponse, error) {
	return &UpdateAccountResponse{}, nil
}

// ListAccount ...
func (m *FolioTxnDefaultServer) ListAccount(ctx context.Context, in *ListAccountRequest) (*ListAccountResponse, error) {
	return &ListAccountResponse{}, nil
}

// DeleteAccount ...
func (m *FolioTxnDefaultServer) DeleteAccount(ctx context.Context, in *DeleteAccountRequest) (*DeleteAccountResponse, error) {
	return &DeleteAccountResponse{}, nil
}

// CreateUser ...
func (m *FolioTxnDefaultServer) CreateUser(ctx context.Context, in *CreateUserRequest) (*CreateUserResponse, error) {
	return &CreateUserResponse{}, nil
}

// ReadUser ...
func (m *FolioTxnDefaultServer) ReadUser(ctx context.Context, in *ReadUserRequest) (*ReadUserResponse, error) {
	return &ReadUserResponse{}, nil
}

// UpdateUser ...
func (m *FolioTxnDefaultServer) UpdateUser(ctx context.Context, in *UpdateUserRequest) (*UpdateUserResponse, error) {
	return &UpdateUserResponse{}, nil
}

// ListUser ...
func (m *FolioTxnDefaultServer) ListUser(ctx context.Context, in *ListUserRequest) (*ListUserResponse, error) {
	return &ListUserResponse{}, nil
}

// DeleteUser ...
func (m *FolioTxnDefaultServer) DeleteUser(ctx context.Context, in *DeleteUserRequest) (*DeleteUserResponse, error) {
	return &DeleteUserResponse{}, nil
}

// CreateArchive ...
func (m *FolioTxnDefaultServer) CreateArchive(ctx context.Context, in *CreateArchiveRequest) (*CreateArchiveResponse, error) {
	return &CreateArchiveResponse{}, nil
}

// ReadArchive ...
func (m *FolioTxnDefaultServer) ReadArchive(ctx context.Context, in *ReadArchiveRequest) (*ReadArchiveResponse, error) {
	return &ReadArchiveResponse{}, nil
}

// UpdateArchive ...
func (m *FolioTxnDefaultServer) UpdateArchive(ctx context.Context, in *UpdateArchiveRequest) (*UpdateArchiveResponse, error) {
	return &UpdateArchiveResponse{}, nil
}

// ListArchive ...
func (m *FolioTxnDefaultServer) ListArchive(ctx context.Context, in *ListArchiveRequest) (*ListArchiveResponse, error) {
	return &ListArchiveResponse{}, nil
}

// DeleteArchive ...
func (m *FolioTxnDefaultServer) DeleteArchive(ctx context.Context, in *DeleteArchiveRequest) (*DeleteArchiveResponse, error) {
	return &DeleteArchiveResponse{}, nil
}

// CreateFolio ...
func (m *FolioTxnDefaultServer) CreateFolio(ctx context.Context, in *CreateFolioRequest) (*CreateFolioResponse, error) {
	return &CreateFolioResponse{}, nil
}

// ReadFolio ...
func (m *FolioTxnDefaultServer) ReadFolio(ctx context.Context, in *ReadFolioRequest) (*ReadFolioResponse, error) {
	return &ReadFolioResponse{}, nil
}

// UpdateFolio ...
func (m *FolioTxnDefaultServer) UpdateFolio(ctx context.Context, in *UpdateFolioRequest) (*UpdateFolioResponse, error) {
	return &UpdateFolioResponse{}, nil
}

// ListFolio ...
func (m *FolioTxnDefaultServer) ListFolio(ctx context.Context, in *ListFolioRequest) (*ListFolioResponse, error) {
	return &ListFolioResponse{}, nil
}

// DeleteFolio ...
func (m *FolioTxnDefaultServer) DeleteFolio(ctx context.Context, in *DeleteFolioRequest) (*DeleteFolioResponse, error) {
	return &DeleteFolioResponse{}, nil
}

// CreateTag ...
func (m *FolioTxnDefaultServer) CreateTag(ctx context.Context, in *CreateTagRequest) (*CreateTagResponse, error) {
	return &CreateTagResponse{}, nil
}

// ReadTag ...
func (m *FolioTxnDefaultServer) ReadTag(ctx context.Context, in *ReadTagRequest) (*ReadTagResponse, error) {
	return &ReadTagResponse{}, nil
}

// UpdateTag ...
func (m *FolioTxnDefaultServer) UpdateTag(ctx context.Context, in *UpdateTagRequest) (*UpdateTagResponse, error) {
	return &UpdateTagResponse{}, nil
}

// ListTag ...
func (m *FolioTxnDefaultServer) ListTag(ctx context.Context, in *ListTagRequest) (*ListTagResponse, error) {
	return &ListTagResponse{}, nil
}

// DeleteTag ...
func (m *FolioTxnDefaultServer) DeleteTag(ctx context.Context, in *DeleteTagRequest) (*DeleteTagResponse, error) {
	return &DeleteTagResponse{}, nil
}

// CreateNote ...
func (m *FolioTxnDefaultServer) CreateNote(ctx context.Context, in *CreateNoteRequest) (*CreateNoteResponse, error) {
	return &CreateNoteResponse{}, nil
}

// ReadNote ...
func (m *FolioTxnDefaultServer) ReadNote(ctx context.Context, in *ReadNoteRequest) (*ReadNoteResponse, error) {
	return &ReadNoteResponse{}, nil
}

// UpdateNote ...
func (m *FolioTxnDefaultServer) UpdateNote(ctx context.Context, in *UpdateNoteRequest) (*UpdateNoteResponse, error) {
	return &UpdateNoteResponse{}, nil
}

// ListNote ...
func (m *FolioTxnDefaultServer) ListNote(ctx context.Context, in *ListNoteRequest) (*ListNoteResponse, error) {
	return &ListNoteResponse{}, nil
}

// DeleteNote ...
func (m *FolioTxnDefaultServer) DeleteNote(ctx context.Context, in *DeleteNoteRequest) (*DeleteNoteResponse, error) {
	return &DeleteNoteResponse{}, nil
}

// CreateAsset ...
func (m *FolioTxnDefaultServer) CreateAsset(ctx context.Context, in *CreateAssetRequest) (*CreateAssetResponse, error) {
	return &CreateAssetResponse{}, nil
}

// ReadAsset ...
func (m *FolioTxnDefaultServer) ReadAsset(ctx context.Context, in *ReadAssetRequest) (*ReadAssetResponse, error) {
	return &ReadAssetResponse{}, nil
}

// UpdateAsset ...
func (m *FolioTxnDefaultServer) UpdateAsset(ctx context.Context, in *UpdateAssetRequest) (*UpdateAssetResponse, error) {
	return &UpdateAssetResponse{}, nil
}

// ListAsset ...
func (m *FolioTxnDefaultServer) ListAsset(ctx context.Context, in *ListAssetRequest) (*ListAssetResponse, error) {
	return &ListAssetResponse{}, nil
}

// DeleteAsset ...
func (m *FolioTxnDefaultServer) DeleteAsset(ctx context.Context, in *DeleteAssetRequest) (*DeleteAssetResponse, error) {
	return &DeleteAssetResponse{}, nil
}

// CreateShare ...
func (m *FolioTxnDefaultServer) CreateShare(ctx context.Context, in *CreateShareRequest) (*CreateShareResponse, error) {
	return &CreateShareResponse{}, nil
}

// ReadShare ...
func (m *FolioTxnDefaultServer) ReadShare(ctx context.Context, in *ReadShareRequest) (*ReadShareResponse, error) {
	return &ReadShareResponse{}, nil
}

// UpdateShare ...
func (m *FolioTxnDefaultServer) UpdateShare(ctx context.Context, in *UpdateShareRequest) (*UpdateShareResponse, error) {
	return &UpdateShareResponse{}, nil
}

// ListShare ...
func (m *FolioTxnDefaultServer) ListShare(ctx context.Context, in *ListShareRequest) (*ListShareResponse, error) {
	return &ListShareResponse{}, nil
}

// DeleteShare ...
func (m *FolioTxnDefaultServer) DeleteShare(ctx context.Context, in *DeleteShareRequest) (*DeleteShareResponse, error) {
	return &DeleteShareResponse{}, nil
}
